const __vite__mapDeps = (i, m = __vite__mapDeps, d = (m.f || (m.f = ["assets/HomeView-DWbD5oR0.js", "assets/HomeView-Do35d1_8.css"]))) => i.map(i => d[i]);
(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) s(r); new MutationObserver(r => { for (const o of r) if (o.type === "childList") for (const i of o.addedNodes) i.tagName === "LINK" && i.rel === "modulepreload" && s(i) }).observe(document, { childList: !0, subtree: !0 }); function n(r) { const o = {}; return r.integrity && (o.integrity = r.integrity), r.referrerPolicy && (o.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? o.credentials = "include" : r.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function s(r) { if (r.ep) return; r.ep = !0; const o = n(r); fetch(r.href, o) } })();/**
* @vue/shared v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Is(e) { const t = Object.create(null); for (const n of e.split(",")) t[n] = 1; return n => n in t } const oe = {}, Vt = [], Ye = () => { }, Gr = () => !1, Un = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Ns = e => e.startsWith("onUpdate:"), ye = Object.assign, Ds = (e, t) => { const n = e.indexOf(t); n > -1 && e.splice(n, 1) }, gi = Object.prototype.hasOwnProperty, X = (e, t) => gi.call(e, t), U = Array.isArray, Ht = e => kn(e) === "[object Map]", Wr = e => kn(e) === "[object Set]", k = e => typeof e == "function", ue = e => typeof e == "string", bt = e => typeof e == "symbol", ie = e => e !== null && typeof e == "object", qr = e => (ie(e) || k(e)) && k(e.then) && k(e.catch), zr = Object.prototype.toString, kn = e => zr.call(e), mi = e => kn(e).slice(8, -1), Yr = e => kn(e) === "[object Object]", Ms = e => ue(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, en = Is(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), Kn = e => { const t = Object.create(null); return (n => t[n] || (t[n] = e(n))) }, _i = /-\w/g, Le = Kn(e => e.replace(_i, t => t.slice(1).toUpperCase())), yi = /\B([A-Z])/g, xt = Kn(e => e.replace(yi, "-$1").toLowerCase()), Gn = Kn(e => e.charAt(0).toUpperCase() + e.slice(1)), ts = Kn(e => e ? `on${Gn(e)}` : ""), _t = (e, t) => !Object.is(e, t), ns = (e, ...t) => { for (let n = 0; n < e.length; n++)e[n](...t) }, Jr = (e, t, n, s = !1) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: s, value: n }) }, vi = e => { const t = parseFloat(e); return isNaN(t) ? e : t }; let Zs; const Wn = () => Zs || (Zs = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function _n(e) { if (U(e)) { const t = {}; for (let n = 0; n < e.length; n++) { const s = e[n], r = ue(s) ? wi(s) : _n(s); if (r) for (const o in r) t[o] = r[o] } return t } else if (ue(e) || ie(e)) return e } const bi = /;(?![^(]*\))/g, xi = /:([^]+)/, Ei = /\/\*[^]*?\*\//g; function wi(e) { const t = {}; return e.replace(Ei, "").split(bi).forEach(n => { if (n) { const s = n.split(xi); s.length > 1 && (t[s[0].trim()] = s[1].trim()) } }), t } function an(e) { let t = ""; if (ue(e)) t = e; else if (U(e)) for (let n = 0; n < e.length; n++) { const s = an(e[n]); s && (t += s + " ") } else if (ie(e)) for (const n in e) e[n] && (t += n + " "); return t.trim() } const Ai = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Ri = Is(Ai); function Qr(e) { return !!e || e === "" } const Xr = e => !!(e && e.__v_isRef === !0), q = e => ue(e) ? e : e == null ? "" : U(e) || ie(e) && (e.toString === zr || !k(e.toString)) ? Xr(e) ? q(e.value) : JSON.stringify(e, Zr, 2) : String(e), Zr = (e, t) => Xr(t) ? Zr(e, t.value) : Ht(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((n, [s, r], o) => (n[ss(s, o) + " =>"] = r, n), {}) } : Wr(t) ? { [`Set(${t.size})`]: [...t.values()].map(n => ss(n)) } : bt(t) ? ss(t) : ie(t) && !U(t) && !Yr(t) ? String(t) : t, ss = (e, t = "") => { var n; return bt(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e };/**
* @vue/reactivity v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Se; class Si { constructor(t = !1) { this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Se, !t && Se && (this.index = (Se.scopes || (Se.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { this._isPaused = !0; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].pause(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].pause() } } resume() { if (this._active && this._isPaused) { this._isPaused = !1; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].resume(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].resume() } } run(t) { if (this._active) { const n = Se; try { return Se = this, t() } finally { Se = n } } } on() { ++this._on === 1 && (this.prevScope = Se, Se = this) } off() { this._on > 0 && --this._on === 0 && (Se = this.prevScope, this.prevScope = void 0) } stop(t) { if (this._active) { this._active = !1; let n, s; for (n = 0, s = this.effects.length; n < s; n++)this.effects[n].stop(); for (this.effects.length = 0, n = 0, s = this.cleanups.length; n < s; n++)this.cleanups[n](); if (this.cleanups.length = 0, this.scopes) { for (n = 0, s = this.scopes.length; n < s; n++)this.scopes[n].stop(!0); this.scopes.length = 0 } if (!this.detached && this.parent && !t) { const r = this.parent.scopes.pop(); r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index) } this.parent = void 0 } } } function Pi() { return Se } let re; const rs = new WeakSet; class eo { constructor(t) { this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Se && Se.active && Se.effects.push(this) } pause() { this.flags |= 64 } resume() { this.flags & 64 && (this.flags &= -65, rs.has(this) && (rs.delete(this), this.trigger())) } notify() { this.flags & 2 && !(this.flags & 32) || this.flags & 8 || no(this) } run() { if (!(this.flags & 1)) return this.fn(); this.flags |= 2, er(this), so(this); const t = re, n = Ve; re = this, Ve = !0; try { return this.fn() } finally { ro(this), re = t, Ve = n, this.flags &= -3 } } stop() { if (this.flags & 1) { for (let t = this.deps; t; t = t.nextDep)Ls(t); this.deps = this.depsTail = void 0, er(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { this.flags & 64 ? rs.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { ms(this) && this.run() } get dirty() { return ms(this) } } let to = 0, tn, nn; function no(e, t = !1) { if (e.flags |= 8, t) { e.next = nn, nn = e; return } e.next = tn, tn = e } function Bs() { to++ } function $s() { if (--to > 0) return; if (nn) { let t = nn; for (nn = void 0; t;) { const n = t.next; t.next = void 0, t.flags &= -9, t = n } } let e; for (; tn;) { let t = tn; for (tn = void 0; t;) { const n = t.next; if (t.next = void 0, t.flags &= -9, t.flags & 1) try { t.trigger() } catch (s) { e || (e = s) } t = n } } if (e) throw e } function so(e) { for (let t = e.deps; t; t = t.nextDep)t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t } function ro(e) { let t, n = e.depsTail, s = n; for (; s;) { const r = s.prevDep; s.version === -1 ? (s === n && (n = r), Ls(s), Ci(s)) : t = s, s.dep.activeLink = s.prevActiveLink, s.prevActiveLink = void 0, s = r } e.deps = t, e.depsTail = n } function ms(e) { for (let t = e.deps; t; t = t.nextDep)if (t.dep.version !== t.version || t.dep.computed && (oo(t.dep.computed) || t.dep.version !== t.version)) return !0; return !!e._dirty } function oo(e) { if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === un) || (e.globalVersion = un, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !ms(e)))) return; e.flags |= 2; const t = e.dep, n = re, s = Ve; re = e, Ve = !0; try { so(e); const r = e.fn(e._value); (t.version === 0 || _t(r, e._value)) && (e.flags |= 128, e._value = r, t.version++) } catch (r) { throw t.version++, r } finally { re = n, Ve = s, ro(e), e.flags &= -3 } } function Ls(e, t = !1) { const { dep: n, prevSub: s, nextSub: r } = e; if (s && (s.nextSub = r, e.prevSub = void 0), r && (r.prevSub = s, e.nextSub = void 0), n.subs === e && (n.subs = s, !s && n.computed)) { n.computed.flags &= -5; for (let o = n.computed.deps; o; o = o.nextDep)Ls(o, !0) } !t && !--n.sc && n.map && n.map.delete(n.key) } function Ci(e) { const { prevDep: t, nextDep: n } = e; t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0) } let Ve = !0; const io = []; function it() { io.push(Ve), Ve = !1 } function lt() { const e = io.pop(); Ve = e === void 0 ? !0 : e } function er(e) { const { cleanup: t } = e; if (e.cleanup = void 0, t) { const n = re; re = void 0; try { t() } finally { re = n } } } let un = 0; class Oi { constructor(t, n) { this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } } class Fs { constructor(t) { this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0 } track(t) { if (!re || !Ve || re === this.computed) return; let n = this.activeLink; if (n === void 0 || n.sub !== re) n = this.activeLink = new Oi(re, this), re.deps ? (n.prevDep = re.depsTail, re.depsTail.nextDep = n, re.depsTail = n) : re.deps = re.depsTail = n, lo(n); else if (n.version === -1 && (n.version = this.version, n.nextDep)) { const s = n.nextDep; s.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = s), n.prevDep = re.depsTail, n.nextDep = void 0, re.depsTail.nextDep = n, re.depsTail = n, re.deps === n && (re.deps = s) } return n } trigger(t) { this.version++, un++, this.notify(t) } notify(t) { Bs(); try { for (let n = this.subs; n; n = n.prevSub)n.sub.notify() && n.sub.dep.notify() } finally { $s() } } } function lo(e) { if (e.dep.sc++, e.sub.flags & 4) { const t = e.dep.computed; if (t && !e.dep.subs) { t.flags |= 20; for (let s = t.deps; s; s = s.nextDep)lo(s) } const n = e.dep.subs; n !== e && (e.prevSub = n, n && (n.nextSub = e)), e.dep.subs = e } } const _s = new WeakMap, Ot = Symbol(""), ys = Symbol(""), fn = Symbol(""); function ge(e, t, n) { if (Ve && re) { let s = _s.get(e); s || _s.set(e, s = new Map); let r = s.get(n); r || (s.set(n, r = new Fs), r.map = s, r.key = n), r.track() } } function rt(e, t, n, s, r, o) { const i = _s.get(e); if (!i) { un++; return } const l = c => { c && c.trigger() }; if (Bs(), t === "clear") i.forEach(l); else { const c = U(e), h = c && Ms(n); if (c && n === "length") { const a = Number(s); i.forEach((f, p) => { (p === "length" || p === fn || !bt(p) && p >= a) && l(f) }) } else switch ((n !== void 0 || i.has(void 0)) && l(i.get(n)), h && l(i.get(fn)), t) { case "add": c ? h && l(i.get("length")) : (l(i.get(Ot)), Ht(e) && l(i.get(ys))); break; case "delete": c || (l(i.get(Ot)), Ht(e) && l(i.get(ys))); break; case "set": Ht(e) && l(i.get(Ot)); break } } $s() } function Nt(e) { const t = Q(e); return t === e ? t : (ge(t, "iterate", fn), $e(e) ? t : t.map(he)) } function qn(e) { return ge(e = Q(e), "iterate", fn), e } const Ti = { __proto__: null, [Symbol.iterator]() { return os(this, Symbol.iterator, he) }, concat(...e) { return Nt(this).concat(...e.map(t => U(t) ? Nt(t) : t)) }, entries() { return os(this, "entries", e => (e[1] = he(e[1]), e)) }, every(e, t) { return Ze(this, "every", e, t, void 0, arguments) }, filter(e, t) { return Ze(this, "filter", e, t, n => n.map(he), arguments) }, find(e, t) { return Ze(this, "find", e, t, he, arguments) }, findIndex(e, t) { return Ze(this, "findIndex", e, t, void 0, arguments) }, findLast(e, t) { return Ze(this, "findLast", e, t, he, arguments) }, findLastIndex(e, t) { return Ze(this, "findLastIndex", e, t, void 0, arguments) }, forEach(e, t) { return Ze(this, "forEach", e, t, void 0, arguments) }, includes(...e) { return is(this, "includes", e) }, indexOf(...e) { return is(this, "indexOf", e) }, join(e) { return Nt(this).join(e) }, lastIndexOf(...e) { return is(this, "lastIndexOf", e) }, map(e, t) { return Ze(this, "map", e, t, void 0, arguments) }, pop() { return Yt(this, "pop") }, push(...e) { return Yt(this, "push", e) }, reduce(e, ...t) { return tr(this, "reduce", e, t) }, reduceRight(e, ...t) { return tr(this, "reduceRight", e, t) }, shift() { return Yt(this, "shift") }, some(e, t) { return Ze(this, "some", e, t, void 0, arguments) }, splice(...e) { return Yt(this, "splice", e) }, toReversed() { return Nt(this).toReversed() }, toSorted(e) { return Nt(this).toSorted(e) }, toSpliced(...e) { return Nt(this).toSpliced(...e) }, unshift(...e) { return Yt(this, "unshift", e) }, values() { return os(this, "values", he) } }; function os(e, t, n) { const s = qn(e), r = s[t](); return s !== e && !$e(e) && (r._next = r.next, r.next = () => { const o = r._next(); return o.done || (o.value = n(o.value)), o }), r } const Ii = Array.prototype; function Ze(e, t, n, s, r, o) { const i = qn(e), l = i !== e && !$e(e), c = i[t]; if (c !== Ii[t]) { const f = c.apply(e, o); return l ? he(f) : f } let h = n; i !== e && (l ? h = function (f, p) { return n.call(this, he(f), p, e) } : n.length > 2 && (h = function (f, p) { return n.call(this, f, p, e) })); const a = c.call(i, h, s); return l && r ? r(a) : a } function tr(e, t, n, s) { const r = qn(e); let o = n; return r !== e && ($e(e) ? n.length > 3 && (o = function (i, l, c) { return n.call(this, i, l, c, e) }) : o = function (i, l, c) { return n.call(this, i, he(l), c, e) }), r[t](o, ...s) } function is(e, t, n) { const s = Q(e); ge(s, "iterate", fn); const r = s[t](...n); return (r === -1 || r === !1) && js(n[0]) ? (n[0] = Q(n[0]), s[t](...n)) : r } function Yt(e, t, n = []) { it(), Bs(); const s = Q(e)[t].apply(e, n); return $s(), lt(), s } const Ni = Is("__proto__,__v_isRef,__isVue"), co = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(bt)); function Di(e) { bt(e) || (e = String(e)); const t = Q(this); return ge(t, "has", e), t.hasOwnProperty(e) } class ao { constructor(t = !1, n = !1) { this._isReadonly = t, this._isShallow = n } get(t, n, s) { if (n === "__v_skip") return t.__v_skip; const r = this._isReadonly, o = this._isShallow; if (n === "__v_isReactive") return !r; if (n === "__v_isReadonly") return r; if (n === "__v_isShallow") return o; if (n === "__v_raw") return s === (r ? o ? ki : po : o ? ho : fo).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(s) ? t : void 0; const i = U(t); if (!r) { let c; if (i && (c = Ti[n])) return c; if (n === "hasOwnProperty") return Di } const l = Reflect.get(t, n, _e(t) ? t : s); if ((bt(n) ? co.has(n) : Ni(n)) || (r || ge(t, "get", n), o)) return l; if (_e(l)) { const c = i && Ms(n) ? l : l.value; return r && ie(c) ? bs(c) : c } return ie(l) ? r ? bs(l) : yn(l) : l } } class uo extends ao { constructor(t = !1) { super(!1, t) } set(t, n, s, r) { let o = t[n]; if (!this._isShallow) { const c = yt(o); if (!$e(s) && !yt(s) && (o = Q(o), s = Q(s)), !U(t) && _e(o) && !_e(s)) return c || (o.value = s), !0 } const i = U(t) && Ms(n) ? Number(n) < t.length : X(t, n), l = Reflect.set(t, n, s, _e(t) ? t : r); return t === Q(r) && (i ? _t(s, o) && rt(t, "set", n, s) : rt(t, "add", n, s)), l } deleteProperty(t, n) { const s = X(t, n); t[n]; const r = Reflect.deleteProperty(t, n); return r && s && rt(t, "delete", n, void 0), r } has(t, n) { const s = Reflect.has(t, n); return (!bt(n) || !co.has(n)) && ge(t, "has", n), s } ownKeys(t) { return ge(t, "iterate", U(t) ? "length" : Ot), Reflect.ownKeys(t) } } class Mi extends ao { constructor(t = !1) { super(!0, t) } set(t, n) { return !0 } deleteProperty(t, n) { return !0 } } const Bi = new uo, $i = new Mi, Li = new uo(!0); const vs = e => e, xn = e => Reflect.getPrototypeOf(e); function Fi(e, t, n) { return function (...s) { const r = this.__v_raw, o = Q(r), i = Ht(o), l = e === "entries" || e === Symbol.iterator && i, c = e === "keys" && i, h = r[e](...s), a = n ? vs : t ? Nn : he; return !t && ge(o, "iterate", c ? ys : Ot), { next() { const { value: f, done: p } = h.next(); return p ? { value: f, done: p } : { value: l ? [a(f[0]), a(f[1])] : a(f), done: p } }, [Symbol.iterator]() { return this } } } } function En(e) { return function (...t) { return e === "delete" ? !1 : e === "clear" ? void 0 : this } } function Vi(e, t) { const n = { get(r) { const o = this.__v_raw, i = Q(o), l = Q(r); e || (_t(r, l) && ge(i, "get", r), ge(i, "get", l)); const { has: c } = xn(i), h = t ? vs : e ? Nn : he; if (c.call(i, r)) return h(o.get(r)); if (c.call(i, l)) return h(o.get(l)); o !== i && o.get(r) }, get size() { const r = this.__v_raw; return !e && ge(Q(r), "iterate", Ot), r.size }, has(r) { const o = this.__v_raw, i = Q(o), l = Q(r); return e || (_t(r, l) && ge(i, "has", r), ge(i, "has", l)), r === l ? o.has(r) : o.has(r) || o.has(l) }, forEach(r, o) { const i = this, l = i.__v_raw, c = Q(l), h = t ? vs : e ? Nn : he; return !e && ge(c, "iterate", Ot), l.forEach((a, f) => r.call(o, h(a), h(f), i)) } }; return ye(n, e ? { add: En("add"), set: En("set"), delete: En("delete"), clear: En("clear") } : { add(r) { !t && !$e(r) && !yt(r) && (r = Q(r)); const o = Q(this); return xn(o).has.call(o, r) || (o.add(r), rt(o, "add", r, r)), this }, set(r, o) { !t && !$e(o) && !yt(o) && (o = Q(o)); const i = Q(this), { has: l, get: c } = xn(i); let h = l.call(i, r); h || (r = Q(r), h = l.call(i, r)); const a = c.call(i, r); return i.set(r, o), h ? _t(o, a) && rt(i, "set", r, o) : rt(i, "add", r, o), this }, delete(r) { const o = Q(this), { has: i, get: l } = xn(o); let c = i.call(o, r); c || (r = Q(r), c = i.call(o, r)), l && l.call(o, r); const h = o.delete(r); return c && rt(o, "delete", r, void 0), h }, clear() { const r = Q(this), o = r.size !== 0, i = r.clear(); return o && rt(r, "clear", void 0, void 0), i } }), ["keys", "values", "entries", Symbol.iterator].forEach(r => { n[r] = Fi(r, e, t) }), n } function Vs(e, t) { const n = Vi(e, t); return (s, r, o) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? s : Reflect.get(X(n, r) && r in s ? n : s, r, o) } const Hi = { get: Vs(!1, !1) }, ji = { get: Vs(!1, !0) }, Ui = { get: Vs(!0, !1) }; const fo = new WeakMap, ho = new WeakMap, po = new WeakMap, ki = new WeakMap; function Ki(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function Gi(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : Ki(mi(e)) } function yn(e) { return yt(e) ? e : Hs(e, !1, Bi, Hi, fo) } function go(e) { return Hs(e, !1, Li, ji, ho) } function bs(e) { return Hs(e, !0, $i, Ui, po) } function Hs(e, t, n, s, r) { if (!ie(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; const o = Gi(e); if (o === 0) return e; const i = r.get(e); if (i) return i; const l = new Proxy(e, o === 2 ? s : n); return r.set(e, l), l } function jt(e) { return yt(e) ? jt(e.__v_raw) : !!(e && e.__v_isReactive) } function yt(e) { return !!(e && e.__v_isReadonly) } function $e(e) { return !!(e && e.__v_isShallow) } function js(e) { return e ? !!e.__v_raw : !1 } function Q(e) { const t = e && e.__v_raw; return t ? Q(t) : e } function Wi(e) { return !X(e, "__v_skip") && Object.isExtensible(e) && Jr(e, "__v_skip", !0), e } const he = e => ie(e) ? yn(e) : e, Nn = e => ie(e) ? bs(e) : e; function _e(e) { return e ? e.__v_isRef === !0 : !1 } function Ft(e) { return mo(e, !1) } function qi(e) { return mo(e, !0) } function mo(e, t) { return _e(e) ? e : new zi(e, t) } class zi { constructor(t, n) { this.dep = new Fs, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? t : Q(t), this._value = n ? t : he(t), this.__v_isShallow = n } get value() { return this.dep.track(), this._value } set value(t) { const n = this._rawValue, s = this.__v_isShallow || $e(t) || yt(t); t = s ? t : Q(t), _t(t, n) && (this._rawValue = t, this._value = s ? t : he(t), this.dep.trigger()) } } function Ut(e) { return _e(e) ? e.value : e } const Yi = { get: (e, t, n) => t === "__v_raw" ? e : Ut(Reflect.get(e, t, n)), set: (e, t, n, s) => { const r = e[t]; return _e(r) && !_e(n) ? (r.value = n, !0) : Reflect.set(e, t, n, s) } }; function _o(e) { return jt(e) ? e : new Proxy(e, Yi) } class Ji { constructor(t, n, s) { this.fn = t, this.setter = n, this._value = void 0, this.dep = new Fs(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = un - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = s } notify() { if (this.flags |= 16, !(this.flags & 8) && re !== this) return no(this, !0), !0 } get value() { const t = this.dep.track(); return oo(this), t && (t.version = this.dep.version), this._value } set value(t) { this.setter && this.setter(t) } } function Qi(e, t, n = !1) { let s, r; return k(e) ? s = e : (s = e.get, r = e.set), new Ji(s, r, n) } const wn = {}, Dn = new WeakMap; let Pt; function Xi(e, t = !1, n = Pt) { if (n) { let s = Dn.get(n); s || Dn.set(n, s = []), s.push(e) } } function Zi(e, t, n = oe) { const { immediate: s, deep: r, once: o, scheduler: i, augmentJob: l, call: c } = n, h = R => r ? R : $e(R) || r === !1 || r === 0 ? mt(R, 1) : mt(R); let a, f, p, m, _ = !1, T = !1; if (_e(e) ? (f = () => e.value, _ = $e(e)) : jt(e) ? (f = () => h(e), _ = !0) : U(e) ? (T = !0, _ = e.some(R => jt(R) || $e(R)), f = () => e.map(R => { if (_e(R)) return R.value; if (jt(R)) return h(R); if (k(R)) return c ? c(R, 2) : R() })) : k(e) ? t ? f = c ? () => c(e, 2) : e : f = () => { if (p) { it(); try { p() } finally { lt() } } const R = Pt; Pt = a; try { return c ? c(e, 3, [m]) : e(m) } finally { Pt = R } } : f = Ye, t && r) { const R = f, V = r === !0 ? 1 / 0 : r; f = () => mt(R(), V) } const H = Pi(), w = () => { a.stop(), H && H.active && Ds(H.effects, a) }; if (o && t) { const R = t; t = (...V) => { R(...V), w() } } let A = T ? new Array(e.length).fill(wn) : wn; const N = R => { if (!(!(a.flags & 1) || !a.dirty && !R)) if (t) { const V = a.run(); if (r || _ || (T ? V.some((B, K) => _t(B, A[K])) : _t(V, A))) { p && p(); const B = Pt; Pt = a; try { const K = [V, A === wn ? void 0 : T && A[0] === wn ? [] : A, m]; A = V, c ? c(t, 3, K) : t(...K) } finally { Pt = B } } } else a.run() }; return l && l(N), a = new eo(f), a.scheduler = i ? () => i(N, !1) : N, m = R => Xi(R, !1, a), p = a.onStop = () => { const R = Dn.get(a); if (R) { if (c) c(R, 4); else for (const V of R) V(); Dn.delete(a) } }, t ? s ? N(!0) : A = a.run() : i ? i(N.bind(null, !0), !0) : a.run(), w.pause = a.pause.bind(a), w.resume = a.resume.bind(a), w.stop = w, w } function mt(e, t = 1 / 0, n) { if (t <= 0 || !ie(e) || e.__v_skip || (n = n || new Map, (n.get(e) || 0) >= t)) return e; if (n.set(e, t), t--, _e(e)) mt(e.value, t, n); else if (U(e)) for (let s = 0; s < e.length; s++)mt(e[s], t, n); else if (Wr(e) || Ht(e)) e.forEach(s => { mt(s, t, n) }); else if (Yr(e)) { for (const s in e) mt(e[s], t, n); for (const s of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, s) && mt(e[s], t, n) } return e }/**
* @vue/runtime-core v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function vn(e, t, n, s) { try { return s ? e(...s) : e() } catch (r) { zn(r, t, n) } } function Je(e, t, n, s) { if (k(e)) { const r = vn(e, t, n, s); return r && qr(r) && r.catch(o => { zn(o, t, n) }), r } if (U(e)) { const r = []; for (let o = 0; o < e.length; o++)r.push(Je(e[o], t, n, s)); return r } } function zn(e, t, n, s = !0) { const r = t ? t.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: i } = t && t.appContext.config || oe; if (t) { let l = t.parent; const c = t.proxy, h = `https://vuejs.org/error-reference/#runtime-${n}`; for (; l;) { const a = l.ec; if (a) { for (let f = 0; f < a.length; f++)if (a[f](e, c, h) === !1) return } l = l.parent } if (o) { it(), vn(o, null, 10, [e, c, h]), lt(); return } } el(e, n, r, s, i) } function el(e, t, n, s = !0, r = !1) { if (r) throw e; console.error(e) } const xe = []; let We = -1; const kt = []; let ht = null, $t = 0; const yo = Promise.resolve(); let Mn = null; function Bn(e) { const t = Mn || yo; return e ? t.then(this ? e.bind(this) : e) : t } function tl(e) { let t = We + 1, n = xe.length; for (; t < n;) { const s = t + n >>> 1, r = xe[s], o = dn(r); o < e || o === e && r.flags & 2 ? t = s + 1 : n = s } return t } function Us(e) { if (!(e.flags & 1)) { const t = dn(e), n = xe[xe.length - 1]; !n || !(e.flags & 2) && t >= dn(n) ? xe.push(e) : xe.splice(tl(t), 0, e), e.flags |= 1, vo() } } function vo() { Mn || (Mn = yo.then(xo)) } function nl(e) { U(e) ? kt.push(...e) : ht && e.id === -1 ? ht.splice($t + 1, 0, e) : e.flags & 1 || (kt.push(e), e.flags |= 1), vo() } function nr(e, t, n = We + 1) { for (; n < xe.length; n++) { const s = xe[n]; if (s && s.flags & 2) { if (e && s.id !== e.uid) continue; xe.splice(n, 1), n--, s.flags & 4 && (s.flags &= -2), s(), s.flags & 4 || (s.flags &= -2) } } } function bo(e) { if (kt.length) { const t = [...new Set(kt)].sort((n, s) => dn(n) - dn(s)); if (kt.length = 0, ht) { ht.push(...t); return } for (ht = t, $t = 0; $t < ht.length; $t++) { const n = ht[$t]; n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2 } ht = null, $t = 0 } } const dn = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id; function xo(e) { try { for (We = 0; We < xe.length; We++) { const t = xe[We]; t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), vn(t, t.i, t.i ? 15 : 14), t.flags & 4 || (t.flags &= -2)) } } finally { for (; We < xe.length; We++) { const t = xe[We]; t && (t.flags &= -2) } We = -1, xe.length = 0, bo(), Mn = null, (xe.length || kt.length) && xo() } } let Fe = null, Eo = null; function $n(e) { const t = Fe; return Fe = e, Eo = e && e.type.__scopeId || null, t } function Yn(e, t = Fe, n) { if (!t || e._n) return e; const s = (...r) => { s._d && Vn(-1); const o = $n(t); let i; try { i = e(...r) } finally { $n(o), s._d && Vn(1) } return i }; return s._n = !0, s._c = !0, s._d = !0, s } function At(e, t, n, s) { const r = e.dirs, o = t && t.dirs; for (let i = 0; i < r.length; i++) { const l = r[i]; o && (l.oldValue = o[i].value); let c = l.dir[s]; c && (it(), Je(c, n, 8, [e.el, l, e, t]), lt()) } } const sl = Symbol("_vte"), rl = e => e.__isTeleport, ol = Symbol("_leaveCb"); function ks(e, t) { e.shapeFlag & 6 && e.component ? (e.transition = t, ks(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t } function wo(e, t) { return k(e) ? ye({ name: e.name }, t, { setup: e }) : e } function Ao(e) { e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0] } const Ln = new WeakMap; function sn(e, t, n, s, r = !1) { if (U(e)) { e.forEach((_, T) => sn(_, t && (U(t) ? t[T] : t), n, s, r)); return } if (rn(s) && !r) { s.shapeFlag & 512 && s.type.__asyncResolved && s.component.subTree.component && sn(e, t, n, s.component.subTree); return } const o = s.shapeFlag & 4 ? qs(s.component) : s.el, i = r ? null : o, { i: l, r: c } = e, h = t && t.r, a = l.refs === oe ? l.refs = {} : l.refs, f = l.setupState, p = Q(f), m = f === oe ? Gr : _ => X(p, _); if (h != null && h !== c) { if (sr(t), ue(h)) a[h] = null, m(h) && (f[h] = null); else if (_e(h)) { h.value = null; const _ = t; _.k && (a[_.k] = null) } } if (k(c)) vn(c, l, 12, [i, a]); else { const _ = ue(c), T = _e(c); if (_ || T) { const H = () => { if (e.f) { const w = _ ? m(c) ? f[c] : a[c] : c.value; if (r) U(w) && Ds(w, o); else if (U(w)) w.includes(o) || w.push(o); else if (_) a[c] = [o], m(c) && (f[c] = a[c]); else { const A = [o]; c.value = A, e.k && (a[e.k] = A) } } else _ ? (a[c] = i, m(c) && (f[c] = i)) : T && (c.value = i, e.k && (a[e.k] = i)) }; if (i) { const w = () => { H(), Ln.delete(e) }; w.id = -1, Ln.set(e, w), Ce(w, n) } else sr(e), H() } } } function sr(e) { const t = Ln.get(e); t && (t.flags |= 8, Ln.delete(e)) } Wn().requestIdleCallback; Wn().cancelIdleCallback; const rn = e => !!e.type.__asyncLoader, Ro = e => e.type.__isKeepAlive; function il(e, t) { So(e, "a", t) } function ll(e, t) { So(e, "da", t) } function So(e, t, n = me) { const s = e.__wdc || (e.__wdc = () => { let r = n; for (; r;) { if (r.isDeactivated) return; r = r.parent } return e() }); if (Jn(t, s, n), n) { let r = n.parent; for (; r && r.parent;)Ro(r.parent.vnode) && cl(s, t, n, r), r = r.parent } } function cl(e, t, n, s) { const r = Jn(t, e, s, !0); Po(() => { Ds(s[t], r) }, n) } function Jn(e, t, n = me, s = !1) { if (n) { const r = n[e] || (n[e] = []), o = t.__weh || (t.__weh = (...i) => { it(); const l = bn(n), c = Je(t, n, e, i); return l(), lt(), c }); return s ? r.unshift(o) : r.push(o), o } } const ct = e => (t, n = me) => { (!gn || e === "sp") && Jn(e, (...s) => t(...s), n) }, al = ct("bm"), ul = ct("m"), fl = ct("bu"), dl = ct("u"), hl = ct("bum"), Po = ct("um"), pl = ct("sp"), gl = ct("rtg"), ml = ct("rtc"); function _l(e, t = me) { Jn("ec", e, t) } const yl = "components"; function Qn(e, t) { return bl(yl, e, !0, t) || e } const vl = Symbol.for("v-ndc"); function bl(e, t, n = !0, s = !1) { const r = Fe || me; if (r) { const o = r.type; { const l = cc(o, !1); if (l && (l === t || l === Le(t) || l === Gn(Le(t)))) return o } const i = rr(r[e] || o[e], t) || rr(r.appContext[e], t); return !i && s ? o : i } } function rr(e, t) { return e && (e[t] || e[Le(t)] || e[Gn(Le(t))]) } function ze(e, t, n, s) { let r; const o = n, i = U(e); if (i || ue(e)) { const l = i && jt(e); let c = !1, h = !1; l && (c = !$e(e), h = yt(e), e = qn(e)), r = new Array(e.length); for (let a = 0, f = e.length; a < f; a++)r[a] = t(c ? h ? Nn(he(e[a])) : he(e[a]) : e[a], a, void 0, o) } else if (typeof e == "number") { r = new Array(e); for (let l = 0; l < e; l++)r[l] = t(l + 1, l, void 0, o) } else if (ie(e)) if (e[Symbol.iterator]) r = Array.from(e, (l, c) => t(l, c, void 0, o)); else { const l = Object.keys(e); r = new Array(l.length); for (let c = 0, h = l.length; c < h; c++) { const a = l[c]; r[c] = t(e[a], a, c, o) } } else r = []; return r } const xs = e => e ? Yo(e) ? qs(e) : xs(e.parent) : null, on = ye(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => xs(e.parent), $root: e => xs(e.root), $host: e => e.ce, $emit: e => e.emit, $options: e => Oo(e), $forceUpdate: e => e.f || (e.f = () => { Us(e.update) }), $nextTick: e => e.n || (e.n = Bn.bind(e.proxy)), $watch: e => jl.bind(e) }), ls = (e, t) => e !== oe && !e.__isScriptSetup && X(e, t), xl = { get({ _: e }, t) { if (t === "__v_skip") return !0; const { ctx: n, setupState: s, data: r, props: o, accessCache: i, type: l, appContext: c } = e; let h; if (t[0] !== "$") { const m = i[t]; if (m !== void 0) switch (m) { case 1: return s[t]; case 2: return r[t]; case 4: return n[t]; case 3: return o[t] } else { if (ls(s, t)) return i[t] = 1, s[t]; if (r !== oe && X(r, t)) return i[t] = 2, r[t]; if ((h = e.propsOptions[0]) && X(h, t)) return i[t] = 3, o[t]; if (n !== oe && X(n, t)) return i[t] = 4, n[t]; Es && (i[t] = 0) } } const a = on[t]; let f, p; if (a) return t === "$attrs" && ge(e.attrs, "get", ""), a(e); if ((f = l.__cssModules) && (f = f[t])) return f; if (n !== oe && X(n, t)) return i[t] = 4, n[t]; if (p = c.config.globalProperties, X(p, t)) return p[t] }, set({ _: e }, t, n) { const { data: s, setupState: r, ctx: o } = e; return ls(r, t) ? (r[t] = n, !0) : s !== oe && X(s, t) ? (s[t] = n, !0) : X(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (o[t] = n, !0) }, has({ _: { data: e, setupState: t, accessCache: n, ctx: s, appContext: r, propsOptions: o, type: i } }, l) { let c, h; return !!(n[l] || e !== oe && l[0] !== "$" && X(e, l) || ls(t, l) || (c = o[0]) && X(c, l) || X(s, l) || X(on, l) || X(r.config.globalProperties, l) || (h = i.__cssModules) && h[l]) }, defineProperty(e, t, n) { return n.get != null ? e._.accessCache[t] = 0 : X(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n) } }; function or(e) { return U(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e } let Es = !0; function El(e) { const t = Oo(e), n = e.proxy, s = e.ctx; Es = !1, t.beforeCreate && ir(t.beforeCreate, e, "bc"); const { data: r, computed: o, methods: i, watch: l, provide: c, inject: h, created: a, beforeMount: f, mounted: p, beforeUpdate: m, updated: _, activated: T, deactivated: H, beforeDestroy: w, beforeUnmount: A, destroyed: N, unmounted: R, render: V, renderTracked: B, renderTriggered: K, errorCaptured: ee, serverPrefetch: Te, expose: Ee, inheritAttrs: Ie, components: Qe, directives: Ne, filters: Et } = t; if (h && wl(h, s, null), i) for (const ne in i) { const Y = i[ne]; k(Y) && (s[ne] = Y.bind(n)) } if (r) { const ne = r.call(n, n); ie(ne) && (e.data = yn(ne)) } if (Es = !0, o) for (const ne in o) { const Y = o[ne], Xe = k(Y) ? Y.bind(n, n) : k(Y.get) ? Y.get.bind(n, n) : Ye, ut = !k(Y) && k(Y.set) ? Y.set.bind(n) : Ye, je = ae({ get: Xe, set: ut }); Object.defineProperty(s, ne, { enumerable: !0, configurable: !0, get: () => je.value, set: we => je.value = we }) } if (l) for (const ne in l) Co(l[ne], s, n, ne); if (c) { const ne = k(c) ? c.call(n) : c; Reflect.ownKeys(ne).forEach(Y => { Pn(Y, ne[Y]) }) } a && ir(a, e, "c"); function de(ne, Y) { U(Y) ? Y.forEach(Xe => ne(Xe.bind(n))) : Y && ne(Y.bind(n)) } if (de(al, f), de(ul, p), de(fl, m), de(dl, _), de(il, T), de(ll, H), de(_l, ee), de(ml, B), de(gl, K), de(hl, A), de(Po, R), de(pl, Te), U(Ee)) if (Ee.length) { const ne = e.exposed || (e.exposed = {}); Ee.forEach(Y => { Object.defineProperty(ne, Y, { get: () => n[Y], set: Xe => n[Y] = Xe, enumerable: !0 }) }) } else e.exposed || (e.exposed = {}); V && e.render === Ye && (e.render = V), Ie != null && (e.inheritAttrs = Ie), Qe && (e.components = Qe), Ne && (e.directives = Ne), Te && Ao(e) } function wl(e, t, n = Ye) { U(e) && (e = ws(e)); for (const s in e) { const r = e[s]; let o; ie(r) ? "default" in r ? o = ot(r.from || s, r.default, !0) : o = ot(r.from || s) : o = ot(r), _e(o) ? Object.defineProperty(t, s, { enumerable: !0, configurable: !0, get: () => o.value, set: i => o.value = i }) : t[s] = o } } function ir(e, t, n) { Je(U(e) ? e.map(s => s.bind(t.proxy)) : e.bind(t.proxy), t, n) } function Co(e, t, n, s) { let r = s.includes(".") ? Uo(n, s) : () => n[s]; if (ue(e)) { const o = t[e]; k(o) && Cn(r, o) } else if (k(e)) Cn(r, e.bind(n)); else if (ie(e)) if (U(e)) e.forEach(o => Co(o, t, n, s)); else { const o = k(e.handler) ? e.handler.bind(n) : t[e.handler]; k(o) && Cn(r, o, e) } } function Oo(e) { const t = e.type, { mixins: n, extends: s } = t, { mixins: r, optionsCache: o, config: { optionMergeStrategies: i } } = e.appContext, l = o.get(t); let c; return l ? c = l : !r.length && !n && !s ? c = t : (c = {}, r.length && r.forEach(h => Fn(c, h, i, !0)), Fn(c, t, i)), ie(t) && o.set(t, c), c } function Fn(e, t, n, s = !1) { const { mixins: r, extends: o } = t; o && Fn(e, o, n, !0), r && r.forEach(i => Fn(e, i, n, !0)); for (const i in t) if (!(s && i === "expose")) { const l = Al[i] || n && n[i]; e[i] = l ? l(e[i], t[i]) : t[i] } return e } const Al = { data: lr, props: cr, emits: cr, methods: Zt, computed: Zt, beforeCreate: ve, created: ve, beforeMount: ve, mounted: ve, beforeUpdate: ve, updated: ve, beforeDestroy: ve, beforeUnmount: ve, destroyed: ve, unmounted: ve, activated: ve, deactivated: ve, errorCaptured: ve, serverPrefetch: ve, components: Zt, directives: Zt, watch: Sl, provide: lr, inject: Rl }; function lr(e, t) { return t ? e ? function () { return ye(k(e) ? e.call(this, this) : e, k(t) ? t.call(this, this) : t) } : t : e } function Rl(e, t) { return Zt(ws(e), ws(t)) } function ws(e) { if (U(e)) { const t = {}; for (let n = 0; n < e.length; n++)t[e[n]] = e[n]; return t } return e } function ve(e, t) { return e ? [...new Set([].concat(e, t))] : t } function Zt(e, t) { return e ? ye(Object.create(null), e, t) : t } function cr(e, t) { return e ? U(e) && U(t) ? [...new Set([...e, ...t])] : ye(Object.create(null), or(e), or(t ?? {})) : t } function Sl(e, t) { if (!e) return t; if (!t) return e; const n = ye(Object.create(null), e); for (const s in t) n[s] = ve(e[s], t[s]); return n } function To() { return { app: null, config: { isNativeTag: Gr, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let Pl = 0; function Cl(e, t) { return function (s, r = null) { k(s) || (s = ye({}, s)), r != null && !ie(r) && (r = null); const o = To(), i = new WeakSet, l = []; let c = !1; const h = o.app = { _uid: Pl++, _component: s, _props: r, _container: null, _context: o, _instance: null, version: uc, get config() { return o.config }, set config(a) { }, use(a, ...f) { return i.has(a) || (a && k(a.install) ? (i.add(a), a.install(h, ...f)) : k(a) && (i.add(a), a(h, ...f))), h }, mixin(a) { return o.mixins.includes(a) || o.mixins.push(a), h }, component(a, f) { return f ? (o.components[a] = f, h) : o.components[a] }, directive(a, f) { return f ? (o.directives[a] = f, h) : o.directives[a] }, mount(a, f, p) { if (!c) { const m = h._ceVNode || pe(s, r); return m.appContext = o, p === !0 ? p = "svg" : p === !1 && (p = void 0), e(m, a, p), c = !0, h._container = a, a.__vue_app__ = h, qs(m.component) } }, onUnmount(a) { l.push(a) }, unmount() { c && (Je(l, h._instance, 16), e(null, h._container), delete h._container.__vue_app__) }, provide(a, f) { return o.provides[a] = f, h }, runWithContext(a) { const f = Kt; Kt = h; try { return a() } finally { Kt = f } } }; return h } } let Kt = null; function Pn(e, t) { if (me) { let n = me.provides; const s = me.parent && me.parent.provides; s === n && (n = me.provides = Object.create(s)), n[e] = t } } function ot(e, t, n = !1) { const s = sc(); if (s || Kt) { let r = Kt ? Kt._context.provides : s ? s.parent == null || s.ce ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides : void 0; if (r && e in r) return r[e]; if (arguments.length > 1) return n && k(t) ? t.call(s && s.proxy) : t } } const Io = {}, No = () => Object.create(Io), Do = e => Object.getPrototypeOf(e) === Io; function Ol(e, t, n, s = !1) { const r = {}, o = No(); e.propsDefaults = Object.create(null), Mo(e, t, r, o); for (const i in e.propsOptions[0]) i in r || (r[i] = void 0); n ? e.props = s ? r : go(r) : e.type.props ? e.props = r : e.props = o, e.attrs = o } function Tl(e, t, n, s) { const { props: r, attrs: o, vnode: { patchFlag: i } } = e, l = Q(r), [c] = e.propsOptions; let h = !1; if ((s || i > 0) && !(i & 16)) { if (i & 8) { const a = e.vnode.dynamicProps; for (let f = 0; f < a.length; f++) { let p = a[f]; if (Xn(e.emitsOptions, p)) continue; const m = t[p]; if (c) if (X(o, p)) m !== o[p] && (o[p] = m, h = !0); else { const _ = Le(p); r[_] = As(c, l, _, m, e, !1) } else m !== o[p] && (o[p] = m, h = !0) } } } else { Mo(e, t, r, o) && (h = !0); let a; for (const f in l) (!t || !X(t, f) && ((a = xt(f)) === f || !X(t, a))) && (c ? n && (n[f] !== void 0 || n[a] !== void 0) && (r[f] = As(c, l, f, void 0, e, !0)) : delete r[f]); if (o !== l) for (const f in o) (!t || !X(t, f)) && (delete o[f], h = !0) } h && rt(e.attrs, "set", "") } function Mo(e, t, n, s) { const [r, o] = e.propsOptions; let i = !1, l; if (t) for (let c in t) { if (en(c)) continue; const h = t[c]; let a; r && X(r, a = Le(c)) ? !o || !o.includes(a) ? n[a] = h : (l || (l = {}))[a] = h : Xn(e.emitsOptions, c) || (!(c in s) || h !== s[c]) && (s[c] = h, i = !0) } if (o) { const c = Q(n), h = l || oe; for (let a = 0; a < o.length; a++) { const f = o[a]; n[f] = As(r, c, f, h[f], e, !X(h, f)) } } return i } function As(e, t, n, s, r, o) { const i = e[n]; if (i != null) { const l = X(i, "default"); if (l && s === void 0) { const c = i.default; if (i.type !== Function && !i.skipFactory && k(c)) { const { propsDefaults: h } = r; if (n in h) s = h[n]; else { const a = bn(r); s = h[n] = c.call(null, t), a() } } else s = c; r.ce && r.ce._setProp(n, s) } i[0] && (o && !l ? s = !1 : i[1] && (s === "" || s === xt(n)) && (s = !0)) } return s } const Il = new WeakMap; function Bo(e, t, n = !1) { const s = n ? Il : t.propsCache, r = s.get(e); if (r) return r; const o = e.props, i = {}, l = []; let c = !1; if (!k(e)) { const a = f => { c = !0; const [p, m] = Bo(f, t, !0); ye(i, p), m && l.push(...m) }; !n && t.mixins.length && t.mixins.forEach(a), e.extends && a(e.extends), e.mixins && e.mixins.forEach(a) } if (!o && !c) return ie(e) && s.set(e, Vt), Vt; if (U(o)) for (let a = 0; a < o.length; a++) { const f = Le(o[a]); ar(f) && (i[f] = oe) } else if (o) for (const a in o) { const f = Le(a); if (ar(f)) { const p = o[a], m = i[f] = U(p) || k(p) ? { type: p } : ye({}, p), _ = m.type; let T = !1, H = !0; if (U(_)) for (let w = 0; w < _.length; ++w) { const A = _[w], N = k(A) && A.name; if (N === "Boolean") { T = !0; break } else N === "String" && (H = !1) } else T = k(_) && _.name === "Boolean"; m[0] = T, m[1] = H, (T || X(m, "default")) && l.push(f) } } const h = [i, l]; return ie(e) && s.set(e, h), h } function ar(e) { return e[0] !== "$" && !en(e) } const Ks = e => e === "_" || e === "_ctx" || e === "$stable", Gs = e => U(e) ? e.map(qe) : [qe(e)], Nl = (e, t, n) => { if (t._n) return t; const s = Yn((...r) => Gs(t(...r)), n); return s._c = !1, s }, $o = (e, t, n) => { const s = e._ctx; for (const r in e) { if (Ks(r)) continue; const o = e[r]; if (k(o)) t[r] = Nl(r, o, s); else if (o != null) { const i = Gs(o); t[r] = () => i } } }, Lo = (e, t) => { const n = Gs(t); e.slots.default = () => n }, Fo = (e, t, n) => { for (const s in t) (n || !Ks(s)) && (e[s] = t[s]) }, Dl = (e, t, n) => { const s = e.slots = No(); if (e.vnode.shapeFlag & 32) { const r = t._; r ? (Fo(s, t, n), n && Jr(s, "_", r, !0)) : $o(t, s) } else t && Lo(e, t) }, Ml = (e, t, n) => { const { vnode: s, slots: r } = e; let o = !0, i = oe; if (s.shapeFlag & 32) { const l = t._; l ? n && l === 1 ? o = !1 : Fo(r, t, n) : (o = !t.$stable, $o(t, r)), i = t } else t && (Lo(e, t), i = { default: 1 }); if (o) for (const l in r) !Ks(l) && i[l] == null && delete r[l] }, Ce = Yl; function Bl(e) { return $l(e) } function $l(e, t) { const n = Wn(); n.__VUE__ = !0; const { insert: s, remove: r, patchProp: o, createElement: i, createText: l, createComment: c, setText: h, setElementText: a, parentNode: f, nextSibling: p, setScopeId: m = Ye, insertStaticContent: _ } = e, T = (u, d, g, v = null, x = null, y = null, O = void 0, C = null, P = !!d.dynamicChildren) => { if (u === d) return; u && !Jt(u, d) && (v = b(u), we(u, x, y, !0), u = null), d.patchFlag === -2 && (P = !1, d.dynamicChildren = null); const { type: E, ref: F, shapeFlag: D } = d; switch (E) { case Zn: H(u, d, g, v); break; case vt: w(u, d, g, v); break; case On: u == null && A(d, g, v, O); break; case ce: Qe(u, d, g, v, x, y, O, C, P); break; default: D & 1 ? V(u, d, g, v, x, y, O, C, P) : D & 6 ? Ne(u, d, g, v, x, y, O, C, P) : (D & 64 || D & 128) && E.process(u, d, g, v, x, y, O, C, P, $) }F != null && x ? sn(F, u && u.ref, y, d || u, !d) : F == null && u && u.ref != null && sn(u.ref, null, y, u, !0) }, H = (u, d, g, v) => { if (u == null) s(d.el = l(d.children), g, v); else { const x = d.el = u.el; d.children !== u.children && h(x, d.children) } }, w = (u, d, g, v) => { u == null ? s(d.el = c(d.children || ""), g, v) : d.el = u.el }, A = (u, d, g, v) => { [u.el, u.anchor] = _(u.children, d, g, v, u.el, u.anchor) }, N = ({ el: u, anchor: d }, g, v) => { let x; for (; u && u !== d;)x = p(u), s(u, g, v), u = x; s(d, g, v) }, R = ({ el: u, anchor: d }) => { let g; for (; u && u !== d;)g = p(u), r(u), u = g; r(d) }, V = (u, d, g, v, x, y, O, C, P) => { d.type === "svg" ? O = "svg" : d.type === "math" && (O = "mathml"), u == null ? B(d, g, v, x, y, O, C, P) : Te(u, d, x, y, O, C, P) }, B = (u, d, g, v, x, y, O, C) => { let P, E; const { props: F, shapeFlag: D, transition: L, dirs: j } = u; if (P = u.el = i(u.type, y, F && F.is, F), D & 8 ? a(P, u.children) : D & 16 && ee(u.children, P, null, v, x, cs(u, y), O, C), j && At(u, null, v, "created"), K(P, u, u.scopeId, O, v), F) { for (const se in F) se !== "value" && !en(se) && o(P, se, null, F[se], y, v); "value" in F && o(P, "value", null, F.value, y), (E = F.onVnodeBeforeMount) && Ge(E, v, u) } j && At(u, null, v, "beforeMount"); const W = Ll(x, L); W && L.beforeEnter(P), s(P, d, g), ((E = F && F.onVnodeMounted) || W || j) && Ce(() => { E && Ge(E, v, u), W && L.enter(P), j && At(u, null, v, "mounted") }, x) }, K = (u, d, g, v, x) => { if (g && m(u, g), v) for (let y = 0; y < v.length; y++)m(u, v[y]); if (x) { let y = x.subTree; if (d === y || Ko(y.type) && (y.ssContent === d || y.ssFallback === d)) { const O = x.vnode; K(u, O, O.scopeId, O.slotScopeIds, x.parent) } } }, ee = (u, d, g, v, x, y, O, C, P = 0) => { for (let E = P; E < u.length; E++) { const F = u[E] = C ? pt(u[E]) : qe(u[E]); T(null, F, d, g, v, x, y, O, C) } }, Te = (u, d, g, v, x, y, O) => { const C = d.el = u.el; let { patchFlag: P, dynamicChildren: E, dirs: F } = d; P |= u.patchFlag & 16; const D = u.props || oe, L = d.props || oe; let j; if (g && Rt(g, !1), (j = L.onVnodeBeforeUpdate) && Ge(j, g, d, u), F && At(d, u, g, "beforeUpdate"), g && Rt(g, !0), (D.innerHTML && L.innerHTML == null || D.textContent && L.textContent == null) && a(C, ""), E ? Ee(u.dynamicChildren, E, C, g, v, cs(d, x), y) : O || Y(u, d, C, null, g, v, cs(d, x), y, !1), P > 0) { if (P & 16) Ie(C, D, L, g, x); else if (P & 2 && D.class !== L.class && o(C, "class", null, L.class, x), P & 4 && o(C, "style", D.style, L.style, x), P & 8) { const W = d.dynamicProps; for (let se = 0; se < W.length; se++) { const te = W[se], Ae = D[te], Re = L[te]; (Re !== Ae || te === "value") && o(C, te, Ae, Re, x, g) } } P & 1 && u.children !== d.children && a(C, d.children) } else !O && E == null && Ie(C, D, L, g, x); ((j = L.onVnodeUpdated) || F) && Ce(() => { j && Ge(j, g, d, u), F && At(d, u, g, "updated") }, v) }, Ee = (u, d, g, v, x, y, O) => { for (let C = 0; C < d.length; C++) { const P = u[C], E = d[C], F = P.el && (P.type === ce || !Jt(P, E) || P.shapeFlag & 198) ? f(P.el) : g; T(P, E, F, null, v, x, y, O, !0) } }, Ie = (u, d, g, v, x) => { if (d !== g) { if (d !== oe) for (const y in d) !en(y) && !(y in g) && o(u, y, d[y], null, x, v); for (const y in g) { if (en(y)) continue; const O = g[y], C = d[y]; O !== C && y !== "value" && o(u, y, C, O, x, v) } "value" in g && o(u, "value", d.value, g.value, x) } }, Qe = (u, d, g, v, x, y, O, C, P) => { const E = d.el = u ? u.el : l(""), F = d.anchor = u ? u.anchor : l(""); let { patchFlag: D, dynamicChildren: L, slotScopeIds: j } = d; j && (C = C ? C.concat(j) : j), u == null ? (s(E, g, v), s(F, g, v), ee(d.children || [], g, F, x, y, O, C, P)) : D > 0 && D & 64 && L && u.dynamicChildren ? (Ee(u.dynamicChildren, L, g, x, y, O, C), (d.key != null || x && d === x.subTree) && Vo(u, d, !0)) : Y(u, d, g, F, x, y, O, C, P) }, Ne = (u, d, g, v, x, y, O, C, P) => { d.slotScopeIds = C, u == null ? d.shapeFlag & 512 ? x.ctx.activate(d, g, v, O, P) : Et(d, g, v, x, y, O, P) : at(u, d, P) }, Et = (u, d, g, v, x, y, O) => { const C = u.component = nc(u, v, x); if (Ro(u) && (C.ctx.renderer = $), rc(C, !1, O), C.asyncDep) { if (x && x.registerDep(C, de, O), !u.el) { const P = C.subTree = pe(vt); w(null, P, d, g), u.placeholder = P.el } } else de(C, u, d, g, x, y, O) }, at = (u, d, g) => { const v = d.component = u.component; if (ql(u, d, g)) if (v.asyncDep && !v.asyncResolved) { ne(v, d, g); return } else v.next = d, v.update(); else d.el = u.el, v.vnode = d }, de = (u, d, g, v, x, y, O) => { const C = () => { if (u.isMounted) { let { next: D, bu: L, u: j, parent: W, vnode: se } = u; { const ke = Ho(u); if (ke) { D && (D.el = se.el, ne(u, D, O)), ke.asyncDep.then(() => { u.isUnmounted || C() }); return } } let te = D, Ae; Rt(u, !1), D ? (D.el = se.el, ne(u, D, O)) : D = se, L && ns(L), (Ae = D.props && D.props.onVnodeBeforeUpdate) && Ge(Ae, W, D, se), Rt(u, !0); const Re = fr(u), Ue = u.subTree; u.subTree = Re, T(Ue, Re, f(Ue.el), b(Ue), u, x, y), D.el = Re.el, te === null && zl(u, Re.el), j && Ce(j, x), (Ae = D.props && D.props.onVnodeUpdated) && Ce(() => Ge(Ae, W, D, se), x) } else { let D; const { el: L, props: j } = d, { bm: W, m: se, parent: te, root: Ae, type: Re } = u, Ue = rn(d); Rt(u, !1), W && ns(W), !Ue && (D = j && j.onVnodeBeforeMount) && Ge(D, te, d), Rt(u, !0); { Ae.ce && Ae.ce._def.shadowRoot !== !1 && Ae.ce._injectChildStyle(Re); const ke = u.subTree = fr(u); T(null, ke, g, v, u, x, y), d.el = ke.el } if (se && Ce(se, x), !Ue && (D = j && j.onVnodeMounted)) { const ke = d; Ce(() => Ge(D, te, ke), x) } (d.shapeFlag & 256 || te && rn(te.vnode) && te.vnode.shapeFlag & 256) && u.a && Ce(u.a, x), u.isMounted = !0, d = g = v = null } }; u.scope.on(); const P = u.effect = new eo(C); u.scope.off(); const E = u.update = P.run.bind(P), F = u.job = P.runIfDirty.bind(P); F.i = u, F.id = u.uid, P.scheduler = () => Us(F), Rt(u, !0), E() }, ne = (u, d, g) => { d.component = u; const v = u.vnode.props; u.vnode = d, u.next = null, Tl(u, d.props, v, g), Ml(u, d.children, g), it(), nr(u), lt() }, Y = (u, d, g, v, x, y, O, C, P = !1) => { const E = u && u.children, F = u ? u.shapeFlag : 0, D = d.children, { patchFlag: L, shapeFlag: j } = d; if (L > 0) { if (L & 128) { ut(E, D, g, v, x, y, O, C, P); return } else if (L & 256) { Xe(E, D, g, v, x, y, O, C, P); return } } j & 8 ? (F & 16 && De(E, x, y), D !== E && a(g, D)) : F & 16 ? j & 16 ? ut(E, D, g, v, x, y, O, C, P) : De(E, x, y, !0) : (F & 8 && a(g, ""), j & 16 && ee(D, g, v, x, y, O, C, P)) }, Xe = (u, d, g, v, x, y, O, C, P) => { u = u || Vt, d = d || Vt; const E = u.length, F = d.length, D = Math.min(E, F); let L; for (L = 0; L < D; L++) { const j = d[L] = P ? pt(d[L]) : qe(d[L]); T(u[L], j, g, null, x, y, O, C, P) } E > F ? De(u, x, y, !0, !1, D) : ee(d, g, v, x, y, O, C, P, D) }, ut = (u, d, g, v, x, y, O, C, P) => { let E = 0; const F = d.length; let D = u.length - 1, L = F - 1; for (; E <= D && E <= L;) { const j = u[E], W = d[E] = P ? pt(d[E]) : qe(d[E]); if (Jt(j, W)) T(j, W, g, null, x, y, O, C, P); else break; E++ } for (; E <= D && E <= L;) { const j = u[D], W = d[L] = P ? pt(d[L]) : qe(d[L]); if (Jt(j, W)) T(j, W, g, null, x, y, O, C, P); else break; D--, L-- } if (E > D) { if (E <= L) { const j = L + 1, W = j < F ? d[j].el : v; for (; E <= L;)T(null, d[E] = P ? pt(d[E]) : qe(d[E]), g, W, x, y, O, C, P), E++ } } else if (E > L) for (; E <= D;)we(u[E], x, y, !0), E++; else { const j = E, W = E, se = new Map; for (E = W; E <= L; E++) { const Pe = d[E] = P ? pt(d[E]) : qe(d[E]); Pe.key != null && se.set(Pe.key, E) } let te, Ae = 0; const Re = L - W + 1; let Ue = !1, ke = 0; const zt = new Array(Re); for (E = 0; E < Re; E++)zt[E] = 0; for (E = j; E <= D; E++) { const Pe = u[E]; if (Ae >= Re) { we(Pe, x, y, !0); continue } let Ke; if (Pe.key != null) Ke = se.get(Pe.key); else for (te = W; te <= L; te++)if (zt[te - W] === 0 && Jt(Pe, d[te])) { Ke = te; break } Ke === void 0 ? we(Pe, x, y, !0) : (zt[Ke - W] = E + 1, Ke >= ke ? ke = Ke : Ue = !0, T(Pe, d[Ke], g, null, x, y, O, C, P), Ae++) } const Js = Ue ? Fl(zt) : Vt; for (te = Js.length - 1, E = Re - 1; E >= 0; E--) { const Pe = W + E, Ke = d[Pe], Qs = d[Pe + 1], Xs = Pe + 1 < F ? Qs.el || Qs.placeholder : v; zt[E] === 0 ? T(null, Ke, g, Xs, x, y, O, C, P) : Ue && (te < 0 || E !== Js[te] ? je(Ke, g, Xs, 2) : te--) } } }, je = (u, d, g, v, x = null) => { const { el: y, type: O, transition: C, children: P, shapeFlag: E } = u; if (E & 6) { je(u.component.subTree, d, g, v); return } if (E & 128) { u.suspense.move(d, g, v); return } if (E & 64) { O.move(u, d, g, $); return } if (O === ce) { s(y, d, g); for (let D = 0; D < P.length; D++)je(P[D], d, g, v); s(u.anchor, d, g); return } if (O === On) { N(u, d, g); return } if (v !== 2 && E & 1 && C) if (v === 0) C.beforeEnter(y), s(y, d, g), Ce(() => C.enter(y), x); else { const { leave: D, delayLeave: L, afterLeave: j } = C, W = () => { u.ctx.isUnmounted ? r(y) : s(y, d, g) }, se = () => { y._isLeaving && y[ol](!0), D(y, () => { W(), j && j() }) }; L ? L(y, W, se) : se() } else s(y, d, g) }, we = (u, d, g, v = !1, x = !1) => { const { type: y, props: O, ref: C, children: P, dynamicChildren: E, shapeFlag: F, patchFlag: D, dirs: L, cacheIndex: j } = u; if (D === -2 && (x = !1), C != null && (it(), sn(C, null, g, u, !0), lt()), j != null && (d.renderCache[j] = void 0), F & 256) { d.ctx.deactivate(u); return } const W = F & 1 && L, se = !rn(u); let te; if (se && (te = O && O.onVnodeBeforeUnmount) && Ge(te, d, u), F & 6) wt(u.component, g, v); else { if (F & 128) { u.suspense.unmount(g, v); return } W && At(u, null, d, "beforeUnmount"), F & 64 ? u.type.remove(u, d, g, $, v) : E && !E.hasOnce && (y !== ce || D > 0 && D & 64) ? De(E, d, g, !1, !0) : (y === ce && D & 384 || !x && F & 16) && De(P, d, g), v && Tt(u) } (se && (te = O && O.onVnodeUnmounted) || W) && Ce(() => { te && Ge(te, d, u), W && At(u, null, d, "unmounted") }, g) }, Tt = u => { const { type: d, el: g, anchor: v, transition: x } = u; if (d === ce) { It(g, v); return } if (d === On) { R(u); return } const y = () => { r(g), x && !x.persisted && x.afterLeave && x.afterLeave() }; if (u.shapeFlag & 1 && x && !x.persisted) { const { leave: O, delayLeave: C } = x, P = () => O(g, y); C ? C(u.el, y, P) : P() } else y() }, It = (u, d) => { let g; for (; u !== d;)g = p(u), r(u), u = g; r(d) }, wt = (u, d, g) => { const { bum: v, scope: x, job: y, subTree: O, um: C, m: P, a: E } = u; ur(P), ur(E), v && ns(v), x.stop(), y && (y.flags |= 8, we(O, u, d, g)), C && Ce(C, d), Ce(() => { u.isUnmounted = !0 }, d) }, De = (u, d, g, v = !1, x = !1, y = 0) => { for (let O = y; O < u.length; O++)we(u[O], d, g, v, x) }, b = u => { if (u.shapeFlag & 6) return b(u.component.subTree); if (u.shapeFlag & 128) return u.suspense.next(); const d = p(u.anchor || u.el), g = d && d[sl]; return g ? p(g) : d }; let M = !1; const I = (u, d, g) => { u == null ? d._vnode && we(d._vnode, null, null, !0) : T(d._vnode || null, u, d, null, null, null, g), d._vnode = u, M || (M = !0, nr(), bo(), M = !1) }, $ = { p: T, um: we, m: je, r: Tt, mt: Et, mc: ee, pc: Y, pbc: Ee, n: b, o: e }; return { render: I, hydrate: void 0, createApp: Cl(I) } } function cs({ type: e, props: t }, n) { return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n } function Rt({ effect: e, job: t }, n) { n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5) } function Ll(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted } function Vo(e, t, n = !1) { const s = e.children, r = t.children; if (U(s) && U(r)) for (let o = 0; o < s.length; o++) { const i = s[o]; let l = r[o]; l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = r[o] = pt(r[o]), l.el = i.el), !n && l.patchFlag !== -2 && Vo(i, l)), l.type === Zn && l.patchFlag !== -1 && (l.el = i.el), l.type === vt && !l.el && (l.el = i.el) } } function Fl(e) { const t = e.slice(), n = [0]; let s, r, o, i, l; const c = e.length; for (s = 0; s < c; s++) { const h = e[s]; if (h !== 0) { if (r = n[n.length - 1], e[r] < h) { t[s] = r, n.push(s); continue } for (o = 0, i = n.length - 1; o < i;)l = o + i >> 1, e[n[l]] < h ? o = l + 1 : i = l; h < e[n[o]] && (o > 0 && (t[s] = n[o - 1]), n[o] = s) } } for (o = n.length, i = n[o - 1]; o-- > 0;)n[o] = i, i = t[i]; return n } function Ho(e) { const t = e.subTree.component; if (t) return t.asyncDep && !t.asyncResolved ? t : Ho(t) } function ur(e) { if (e) for (let t = 0; t < e.length; t++)e[t].flags |= 8 } const Vl = Symbol.for("v-scx"), Hl = () => ot(Vl); function Cn(e, t, n) { return jo(e, t, n) } function jo(e, t, n = oe) { const { immediate: s, deep: r, flush: o, once: i } = n, l = ye({}, n), c = t && s || !t && o !== "post"; let h; if (gn) { if (o === "sync") { const m = Hl(); h = m.__watcherHandles || (m.__watcherHandles = []) } else if (!c) { const m = () => { }; return m.stop = Ye, m.resume = Ye, m.pause = Ye, m } } const a = me; l.call = (m, _, T) => Je(m, a, _, T); let f = !1; o === "post" ? l.scheduler = m => { Ce(m, a && a.suspense) } : o !== "sync" && (f = !0, l.scheduler = (m, _) => { _ ? m() : Us(m) }), l.augmentJob = m => { t && (m.flags |= 4), f && (m.flags |= 2, a && (m.id = a.uid, m.i = a)) }; const p = Zi(e, t, l); return gn && (h ? h.push(p) : c && p()), p } function jl(e, t, n) { const s = this.proxy, r = ue(e) ? e.includes(".") ? Uo(s, e) : () => s[e] : e.bind(s, s); let o; k(t) ? o = t : (o = t.handler, n = t); const i = bn(this), l = jo(r, o.bind(s), n); return i(), l } function Uo(e, t) { const n = t.split("."); return () => { let s = e; for (let r = 0; r < n.length && s; r++)s = s[n[r]]; return s } } const Ul = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${Le(t)}Modifiers`] || e[`${xt(t)}Modifiers`]; function kl(e, t, ...n) { if (e.isUnmounted) return; const s = e.vnode.props || oe; let r = n; const o = t.startsWith("update:"), i = o && Ul(s, t.slice(7)); i && (i.trim && (r = n.map(a => ue(a) ? a.trim() : a)), i.number && (r = n.map(vi))); let l, c = s[l = ts(t)] || s[l = ts(Le(t))]; !c && o && (c = s[l = ts(xt(t))]), c && Je(c, e, 6, r); const h = s[l + "Once"]; if (h) { if (!e.emitted) e.emitted = {}; else if (e.emitted[l]) return; e.emitted[l] = !0, Je(h, e, 6, r) } } const Kl = new WeakMap; function ko(e, t, n = !1) { const s = n ? Kl : t.emitsCache, r = s.get(e); if (r !== void 0) return r; const o = e.emits; let i = {}, l = !1; if (!k(e)) { const c = h => { const a = ko(h, t, !0); a && (l = !0, ye(i, a)) }; !n && t.mixins.length && t.mixins.forEach(c), e.extends && c(e.extends), e.mixins && e.mixins.forEach(c) } return !o && !l ? (ie(e) && s.set(e, null), null) : (U(o) ? o.forEach(c => i[c] = null) : ye(i, o), ie(e) && s.set(e, i), i) } function Xn(e, t) { return !e || !Un(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), X(e, t[0].toLowerCase() + t.slice(1)) || X(e, xt(t)) || X(e, t)) } function fr(e) { const { type: t, vnode: n, proxy: s, withProxy: r, propsOptions: [o], slots: i, attrs: l, emit: c, render: h, renderCache: a, props: f, data: p, setupState: m, ctx: _, inheritAttrs: T } = e, H = $n(e); let w, A; try { if (n.shapeFlag & 4) { const R = r || s, V = R; w = qe(h.call(V, R, a, f, m, p, _)), A = l } else { const R = t; w = qe(R.length > 1 ? R(f, { attrs: l, slots: i, emit: c }) : R(f, null)), A = t.props ? l : Gl(l) } } catch (R) { ln.length = 0, zn(R, e, 1), w = pe(vt) } let N = w; if (A && T !== !1) { const R = Object.keys(A), { shapeFlag: V } = N; R.length && V & 7 && (o && R.some(Ns) && (A = Wl(A, o)), N = Gt(N, A, !1, !0)) } return n.dirs && (N = Gt(N, null, !1, !0), N.dirs = N.dirs ? N.dirs.concat(n.dirs) : n.dirs), n.transition && ks(N, n.transition), w = N, $n(H), w } const Gl = e => { let t; for (const n in e) (n === "class" || n === "style" || Un(n)) && ((t || (t = {}))[n] = e[n]); return t }, Wl = (e, t) => { const n = {}; for (const s in e) (!Ns(s) || !(s.slice(9) in t)) && (n[s] = e[s]); return n }; function ql(e, t, n) { const { props: s, children: r, component: o } = e, { props: i, children: l, patchFlag: c } = t, h = o.emitsOptions; if (t.dirs || t.transition) return !0; if (n && c >= 0) { if (c & 1024) return !0; if (c & 16) return s ? dr(s, i, h) : !!i; if (c & 8) { const a = t.dynamicProps; for (let f = 0; f < a.length; f++) { const p = a[f]; if (i[p] !== s[p] && !Xn(h, p)) return !0 } } } else return (r || l) && (!l || !l.$stable) ? !0 : s === i ? !1 : s ? i ? dr(s, i, h) : !0 : !!i; return !1 } function dr(e, t, n) { const s = Object.keys(t); if (s.length !== Object.keys(e).length) return !0; for (let r = 0; r < s.length; r++) { const o = s[r]; if (t[o] !== e[o] && !Xn(n, o)) return !0 } return !1 } function zl({ vnode: e, parent: t }, n) { for (; t;) { const s = t.subTree; if (s.suspense && s.suspense.activeBranch === e && (s.el = e.el), s === e) (e = t.vnode).el = n, t = t.parent; else break } } const Ko = e => e.__isSuspense; function Yl(e, t) { t && t.pendingBranch ? U(e) ? t.effects.push(...e) : t.effects.push(e) : nl(e) } const ce = Symbol.for("v-fgt"), Zn = Symbol.for("v-txt"), vt = Symbol.for("v-cmt"), On = Symbol.for("v-stc"), ln = []; let Oe = null; function z(e = !1) { ln.push(Oe = e ? null : []) } function Jl() { ln.pop(), Oe = ln[ln.length - 1] || null } let hn = 1; function Vn(e, t = !1) { hn += e, e < 0 && Oe && t && (Oe.hasOnce = !0) } function Go(e) { return e.dynamicChildren = hn > 0 ? Oe || Vt : null, Jl(), hn > 0 && Oe && Oe.push(e), e } function Z(e, t, n, s, r, o) { return Go(S(e, t, n, s, r, o, !0)) } function Wo(e, t, n, s, r) { return Go(pe(e, t, n, s, r, !0)) } function Hn(e) { return e ? e.__v_isVNode === !0 : !1 } function Jt(e, t) { return e.type === t.type && e.key === t.key } const qo = ({ key: e }) => e ?? null, Tn = ({ ref: e, ref_key: t, ref_for: n }) => (typeof e == "number" && (e = "" + e), e != null ? ue(e) || _e(e) || k(e) ? { i: Fe, r: e, k: t, f: !!n } : e : null); function S(e, t = null, n = null, s = 0, r = null, o = e === ce ? 0 : 1, i = !1, l = !1) { const c = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && qo(t), ref: t && Tn(t), scopeId: Eo, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: o, patchFlag: s, dynamicProps: r, dynamicChildren: null, appContext: null, ctx: Fe }; return l ? (Ws(c, n), o & 128 && e.normalize(c)) : n && (c.shapeFlag |= ue(n) ? 8 : 16), hn > 0 && !i && Oe && (c.patchFlag > 0 || o & 6) && c.patchFlag !== 32 && Oe.push(c), c } const pe = Ql; function Ql(e, t = null, n = null, s = 0, r = null, o = !1) { if ((!e || e === vl) && (e = vt), Hn(e)) { const l = Gt(e, t, !0); return n && Ws(l, n), hn > 0 && !o && Oe && (l.shapeFlag & 6 ? Oe[Oe.indexOf(e)] = l : Oe.push(l)), l.patchFlag = -2, l } if (ac(e) && (e = e.__vccOpts), t) { t = Xl(t); let { class: l, style: c } = t; l && !ue(l) && (t.class = an(l)), ie(c) && (js(c) && !U(c) && (c = ye({}, c)), t.style = _n(c)) } const i = ue(e) ? 1 : Ko(e) ? 128 : rl(e) ? 64 : ie(e) ? 4 : k(e) ? 2 : 0; return S(e, t, n, s, r, i, o, !0) } function Xl(e) { return e ? js(e) || Do(e) ? ye({}, e) : e : null } function Gt(e, t, n = !1, s = !1) { const { props: r, ref: o, patchFlag: i, children: l, transition: c } = e, h = t ? Zl(r || {}, t) : r, a = { __v_isVNode: !0, __v_skip: !0, type: e.type, props: h, key: h && qo(h), ref: t && t.ref ? n && o ? U(o) ? o.concat(Tn(t)) : [o, Tn(t)] : Tn(t) : o, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: l, target: e.target, targetStart: e.targetStart, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== ce ? i === -1 ? 16 : i | 16 : i, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: c, component: e.component, suspense: e.suspense, ssContent: e.ssContent && Gt(e.ssContent), ssFallback: e.ssFallback && Gt(e.ssFallback), placeholder: e.placeholder, el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce }; return c && s && ks(a, c.clone(a)), a } function pn(e = " ", t = 0) { return pe(Zn, null, e, t) } function zo(e, t) { const n = pe(On, null, e); return n.staticCount = t, n } function An(e = "", t = !1) { return t ? (z(), Wo(vt, null, e)) : pe(vt, null, e) } function qe(e) { return e == null || typeof e == "boolean" ? pe(vt) : U(e) ? pe(ce, null, e.slice()) : Hn(e) ? pt(e) : pe(Zn, null, String(e)) } function pt(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : Gt(e) } function Ws(e, t) { let n = 0; const { shapeFlag: s } = e; if (t == null) t = null; else if (U(t)) n = 16; else if (typeof t == "object") if (s & 65) { const r = t.default; r && (r._c && (r._d = !1), Ws(e, r()), r._c && (r._d = !0)); return } else { n = 32; const r = t._; !r && !Do(t) ? t._ctx = Fe : r === 3 && Fe && (Fe.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else k(t) ? (t = { default: t, _ctx: Fe }, n = 32) : (t = String(t), s & 64 ? (n = 16, t = [pn(t)]) : n = 8); e.children = t, e.shapeFlag |= n } function Zl(...e) { const t = {}; for (let n = 0; n < e.length; n++) { const s = e[n]; for (const r in s) if (r === "class") t.class !== s.class && (t.class = an([t.class, s.class])); else if (r === "style") t.style = _n([t.style, s.style]); else if (Un(r)) { const o = t[r], i = s[r]; i && o !== i && !(U(o) && o.includes(i)) && (t[r] = o ? [].concat(o, i) : i) } else r !== "" && (t[r] = s[r]) } return t } function Ge(e, t, n, s = null) { Je(e, t, 7, [n, s]) } const ec = To(); let tc = 0; function nc(e, t, n) { const s = e.type, r = (t ? t.appContext : e.appContext) || ec, o = { uid: tc++, vnode: e, type: s, parent: t, appContext: r, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new Si(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(r.provides), ids: t ? t.ids : ["", 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: Bo(s, r), emitsOptions: ko(s, r), emit: null, emitted: null, propsDefaults: oe, inheritAttrs: s.inheritAttrs, ctx: oe, data: oe, props: oe, attrs: oe, slots: oe, refs: oe, setupState: oe, setupContext: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return o.ctx = { _: o }, o.root = t ? t.root : o, o.emit = kl.bind(null, o), e.ce && e.ce(o), o } let me = null; const sc = () => me || Fe; let jn, Rs; { const e = Wn(), t = (n, s) => { let r; return (r = e[n]) || (r = e[n] = []), r.push(s), o => { r.length > 1 ? r.forEach(i => i(o)) : r[0](o) } }; jn = t("__VUE_INSTANCE_SETTERS__", n => me = n), Rs = t("__VUE_SSR_SETTERS__", n => gn = n) } const bn = e => { const t = me; return jn(e), e.scope.on(), () => { e.scope.off(), jn(t) } }, hr = () => { me && me.scope.off(), jn(null) }; function Yo(e) { return e.vnode.shapeFlag & 4 } let gn = !1; function rc(e, t = !1, n = !1) { t && Rs(t); const { props: s, children: r } = e.vnode, o = Yo(e); Ol(e, s, o, t), Dl(e, r, n || t); const i = o ? oc(e, t) : void 0; return t && Rs(!1), i } function oc(e, t) { const n = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, xl); const { setup: s } = n; if (s) { it(); const r = e.setupContext = s.length > 1 ? lc(e) : null, o = bn(e), i = vn(s, e, 0, [e.props, r]), l = qr(i); if (lt(), o(), (l || e.sp) && !rn(e) && Ao(e), l) { if (i.then(hr, hr), t) return i.then(c => { pr(e, c) }).catch(c => { zn(c, e, 0) }); e.asyncDep = i } else pr(e, i) } else Jo(e) } function pr(e, t, n) { k(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : ie(t) && (e.setupState = _o(t)), Jo(e) } function Jo(e, t, n) { const s = e.type; e.render || (e.render = s.render || Ye); { const r = bn(e); it(); try { El(e) } finally { lt(), r() } } } const ic = { get(e, t) { return ge(e, "get", ""), e[t] } }; function lc(e) { const t = n => { e.exposed = n || {} }; return { attrs: new Proxy(e.attrs, ic), slots: e.slots, emit: e.emit, expose: t } } function qs(e) { return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(_o(Wi(e.exposed)), { get(t, n) { if (n in t) return t[n]; if (n in on) return on[n](e) }, has(t, n) { return n in t || n in on } })) : e.proxy } function cc(e, t = !0) { return k(e) ? e.displayName || e.name : e.name || t && e.__name } function ac(e) { return k(e) && "__vccOpts" in e } const ae = (e, t) => Qi(e, t, gn); function Qo(e, t, n) { try { Vn(-1); const s = arguments.length; return s === 2 ? ie(t) && !U(t) ? Hn(t) ? pe(e, null, [t]) : pe(e, t) : pe(e, null, t) : (s > 3 ? n = Array.prototype.slice.call(arguments, 2) : s === 3 && Hn(n) && (n = [n]), pe(e, t, n)) } finally { Vn(1) } } const uc = "3.5.22";/**
* @vue/runtime-dom v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Ss; const gr = typeof window < "u" && window.trustedTypes; if (gr) try { Ss = gr.createPolicy("vue", { createHTML: e => e }) } catch { } const Xo = Ss ? e => Ss.createHTML(e) : e => e, fc = "http://www.w3.org/2000/svg", dc = "http://www.w3.org/1998/Math/MathML", st = typeof document < "u" ? document : null, mr = st && st.createElement("template"), hc = { insert: (e, t, n) => { t.insertBefore(e, n || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, n, s) => { const r = t === "svg" ? st.createElementNS(fc, e) : t === "mathml" ? st.createElementNS(dc, e) : n ? st.createElement(e, { is: n }) : st.createElement(e); return e === "select" && s && s.multiple != null && r.setAttribute("multiple", s.multiple), r }, createText: e => st.createTextNode(e), createComment: e => st.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => st.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, n, s, r, o) { const i = n ? n.previousSibling : t.lastChild; if (r && (r === o || r.nextSibling)) for (; t.insertBefore(r.cloneNode(!0), n), !(r === o || !(r = r.nextSibling));); else { mr.innerHTML = Xo(s === "svg" ? `<svg>${e}</svg>` : s === "mathml" ? `<math>${e}</math>` : e); const l = mr.content; if (s === "svg" || s === "mathml") { const c = l.firstChild; for (; c.firstChild;)l.appendChild(c.firstChild); l.removeChild(c) } t.insertBefore(l, n) } return [i ? i.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild] } }, pc = Symbol("_vtc"); function gc(e, t, n) { const s = e[pc]; s && (t = (t ? [t, ...s] : [...s]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t } const _r = Symbol("_vod"), mc = Symbol("_vsh"), _c = Symbol(""), yc = /(?:^|;)\s*display\s*:/; function vc(e, t, n) { const s = e.style, r = ue(n); let o = !1; if (n && !r) { if (t) if (ue(t)) for (const i of t.split(";")) { const l = i.slice(0, i.indexOf(":")).trim(); n[l] == null && In(s, l, "") } else for (const i in t) n[i] == null && In(s, i, ""); for (const i in n) i === "display" && (o = !0), In(s, i, n[i]) } else if (r) { if (t !== n) { const i = s[_c]; i && (n += ";" + i), s.cssText = n, o = yc.test(n) } } else t && e.removeAttribute("style"); _r in e && (e[_r] = o ? s.display : "", e[mc] && (s.display = "none")) } const yr = /\s*!important$/; function In(e, t, n) { if (U(n)) n.forEach(s => In(e, t, s)); else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n); else { const s = bc(e, t); yr.test(n) ? e.setProperty(xt(s), n.replace(yr, ""), "important") : e[s] = n } } const vr = ["Webkit", "Moz", "ms"], as = {}; function bc(e, t) { const n = as[t]; if (n) return n; let s = Le(t); if (s !== "filter" && s in e) return as[t] = s; s = Gn(s); for (let r = 0; r < vr.length; r++) { const o = vr[r] + s; if (o in e) return as[t] = o } return t } const br = "http://www.w3.org/1999/xlink"; function xr(e, t, n, s, r, o = Ri(t)) { s && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(br, t.slice(6, t.length)) : e.setAttributeNS(br, t, n) : n == null || o && !Qr(n) ? e.removeAttribute(t) : e.setAttribute(t, o ? "" : bt(n) ? String(n) : n) } function Er(e, t, n, s, r) { if (t === "innerHTML" || t === "textContent") { n != null && (e[t] = t === "innerHTML" ? Xo(n) : n); return } const o = e.tagName; if (t === "value" && o !== "PROGRESS" && !o.includes("-")) { const l = o === "OPTION" ? e.getAttribute("value") || "" : e.value, c = n == null ? e.type === "checkbox" ? "on" : "" : String(n); (l !== c || !("_value" in e)) && (e.value = c), n == null && e.removeAttribute(t), e._value = n; return } let i = !1; if (n === "" || n == null) { const l = typeof e[t]; l === "boolean" ? n = Qr(n) : n == null && l === "string" ? (n = "", i = !0) : l === "number" && (n = 0, i = !0) } try { e[t] = n } catch { } i && e.removeAttribute(r || t) } function xc(e, t, n, s) { e.addEventListener(t, n, s) } function Ec(e, t, n, s) { e.removeEventListener(t, n, s) } const wr = Symbol("_vei"); function wc(e, t, n, s, r = null) { const o = e[wr] || (e[wr] = {}), i = o[t]; if (s && i) i.value = s; else { const [l, c] = Ac(t); if (s) { const h = o[t] = Pc(s, r); xc(e, l, h, c) } else i && (Ec(e, l, i, c), o[t] = void 0) } } const Ar = /(?:Once|Passive|Capture)$/; function Ac(e) { let t; if (Ar.test(e)) { t = {}; let s; for (; s = e.match(Ar);)e = e.slice(0, e.length - s[0].length), t[s[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : xt(e.slice(2)), t] } let us = 0; const Rc = Promise.resolve(), Sc = () => us || (Rc.then(() => us = 0), us = Date.now()); function Pc(e, t) { const n = s => { if (!s._vts) s._vts = Date.now(); else if (s._vts <= n.attached) return; Je(Cc(s, n.value), t, 5, [s]) }; return n.value = e, n.attached = Sc(), n } function Cc(e, t) { if (U(t)) { const n = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { n.call(e), e._stopped = !0 }, t.map(s => r => !r._stopped && s && s(r)) } else return t } const Rr = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, Oc = (e, t, n, s, r, o) => { const i = r === "svg"; t === "class" ? gc(e, s, i) : t === "style" ? vc(e, n, s) : Un(t) ? Ns(t) || wc(e, t, n, s, o) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : Tc(e, t, s, i)) ? (Er(e, t, s), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && xr(e, t, s, i, o, t !== "value")) : e._isVueCE && (/[A-Z]/.test(t) || !ue(s)) ? Er(e, Le(t), s, o, t) : (t === "true-value" ? e._trueValue = s : t === "false-value" && (e._falseValue = s), xr(e, t, s, i)) }; function Tc(e, t, n, s) { if (s) return !!(t === "innerHTML" || t === "textContent" || t in e && Rr(t) && k(n)); if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1; if (t === "width" || t === "height") { const r = e.tagName; if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE") return !1 } return Rr(t) && ue(n) ? !1 : t in e } const Ic = ["ctrl", "shift", "alt", "meta"], Nc = { stop: e => e.stopPropagation(), prevent: e => e.preventDefault(), self: e => e.target !== e.currentTarget, ctrl: e => !e.ctrlKey, shift: e => !e.shiftKey, alt: e => !e.altKey, meta: e => !e.metaKey, left: e => "button" in e && e.button !== 0, middle: e => "button" in e && e.button !== 1, right: e => "button" in e && e.button !== 2, exact: (e, t) => Ic.some(n => e[`${n}Key`] && !t.includes(n)) }, Qt = (e, t) => { const n = e._withMods || (e._withMods = {}), s = t.join("."); return n[s] || (n[s] = ((r, ...o) => { for (let i = 0; i < t.length; i++) { const l = Nc[t[i]]; if (l && l(r, t)) return } return e(r, ...o) })) }, Dc = { esc: "escape", space: " ", up: "arrow-up", left: "arrow-left", right: "arrow-right", down: "arrow-down", delete: "backspace" }, Sr = (e, t) => { const n = e._withKeys || (e._withKeys = {}), s = t.join("."); return n[s] || (n[s] = (r => { if (!("key" in r)) return; const o = xt(r.key); if (t.some(i => i === o || Dc[i] === o)) return e(r) })) }, Mc = ye({ patchProp: Oc }, hc); let Pr; function Bc() { return Pr || (Pr = Bl(Mc)) } const $c = ((...e) => { const t = Bc().createApp(...e), { mount: n } = t; return t.mount = s => { const r = Fc(s); if (!r) return; const o = t._component; !k(o) && !o.render && !o.template && (o.template = r.innerHTML), r.nodeType === 1 && (r.textContent = ""); const i = n(r, !1, Lc(r)); return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), i }, t }); function Lc(e) { if (e instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml" } function Fc(e) { return ue(e) ? document.querySelector(e) : e } const Zo = (e, t) => { const n = e.__vccOpts || e; for (const [s, r] of t) n[s] = r; return n }, Vc = { __name: "App", setup(e) { return (t, n) => { const s = Qn("router-view"); return z(), Wo(s) } } }, Hc = "modulepreload", jc = function (e) { return "/" + e }, Cr = {}, Uc = function (t, n, s) { let r = Promise.resolve(); if (n && n.length > 0) { let c = function (h) { return Promise.all(h.map(a => Promise.resolve(a).then(f => ({ status: "fulfilled", value: f }), f => ({ status: "rejected", reason: f })))) }; document.getElementsByTagName("link"); const i = document.querySelector("meta[property=csp-nonce]"), l = i?.nonce || i?.getAttribute("nonce"); r = c(n.map(h => { if (h = jc(h), h in Cr) return; Cr[h] = !0; const a = h.endsWith(".css"), f = a ? '[rel="stylesheet"]' : ""; if (document.querySelector(`link[href="${h}"]${f}`)) return; const p = document.createElement("link"); if (p.rel = a ? "stylesheet" : Hc, a || (p.as = "script"), p.crossOrigin = "", p.href = h, l && p.setAttribute("nonce", l), document.head.appendChild(p), a) return new Promise((m, _) => { p.addEventListener("load", m), p.addEventListener("error", () => _(new Error(`Unable to preload CSS for ${h}`))) }) })) } function o(i) { const l = new Event("vite:preloadError", { cancelable: !0 }); if (l.payload = i, window.dispatchEvent(l), !l.defaultPrevented) throw i } return r.then(i => { for (const l of i || []) l.status === "rejected" && o(l.reason); return t().catch(o) }) };/*!
 * vue-router v4.6.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */const Lt = typeof document < "u"; function ei(e) { return typeof e == "object" || "displayName" in e || "props" in e || "__vccOpts" in e } function kc(e) { return e.__esModule || e[Symbol.toStringTag] === "Module" || e.default && ei(e.default) } const J = Object.assign; function fs(e, t) { const n = {}; for (const s in t) { const r = t[s]; n[s] = He(r) ? r.map(e) : e(r) } return n } const cn = () => { }, He = Array.isArray; function Or(e, t) { const n = {}; for (const s in e) n[s] = s in t ? t[s] : e[s]; return n } const ti = /#/g, Kc = /&/g, Gc = /\//g, Wc = /=/g, qc = /\?/g, ni = /\+/g, zc = /%5B/g, Yc = /%5D/g, si = /%5E/g, Jc = /%60/g, ri = /%7B/g, Qc = /%7C/g, oi = /%7D/g, Xc = /%20/g; function zs(e) { return e == null ? "" : encodeURI("" + e).replace(Qc, "|").replace(zc, "[").replace(Yc, "]") } function Zc(e) { return zs(e).replace(ri, "{").replace(oi, "}").replace(si, "^") } function Ps(e) { return zs(e).replace(ni, "%2B").replace(Xc, "+").replace(ti, "%23").replace(Kc, "%26").replace(Jc, "`").replace(ri, "{").replace(oi, "}").replace(si, "^") } function ea(e) { return Ps(e).replace(Wc, "%3D") } function ta(e) { return zs(e).replace(ti, "%23").replace(qc, "%3F") } function na(e) { return ta(e).replace(Gc, "%2F") } function mn(e) { if (e == null) return null; try { return decodeURIComponent("" + e) } catch { } return "" + e } const sa = /\/$/, ra = e => e.replace(sa, ""); function ds(e, t, n = "/") { let s, r = {}, o = "", i = ""; const l = t.indexOf("#"); let c = t.indexOf("?"); return c = l >= 0 && c > l ? -1 : c, c >= 0 && (s = t.slice(0, c), o = t.slice(c, l > 0 ? l : t.length), r = e(o.slice(1))), l >= 0 && (s = s || t.slice(0, l), i = t.slice(l, t.length)), s = ca(s ?? t, n), { fullPath: s + o + i, path: s, query: r, hash: mn(i) } } function oa(e, t) { const n = t.query ? e(t.query) : ""; return t.path + (n && "?") + n + (t.hash || "") } function Tr(e, t) { return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/" } function ia(e, t, n) { const s = t.matched.length - 1, r = n.matched.length - 1; return s > -1 && s === r && Wt(t.matched[s], n.matched[r]) && ii(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash } function Wt(e, t) { return (e.aliasOf || e) === (t.aliasOf || t) } function ii(e, t) { if (Object.keys(e).length !== Object.keys(t).length) return !1; for (const n in e) if (!la(e[n], t[n])) return !1; return !0 } function la(e, t) { return He(e) ? Ir(e, t) : He(t) ? Ir(t, e) : e === t } function Ir(e, t) { return He(t) ? e.length === t.length && e.every((n, s) => n === t[s]) : e.length === 1 && e[0] === t } function ca(e, t) { if (e.startsWith("/")) return e; if (!e) return t; const n = t.split("/"), s = e.split("/"), r = s[s.length - 1]; (r === ".." || r === ".") && s.push(""); let o = n.length - 1, i, l; for (i = 0; i < s.length; i++)if (l = s[i], l !== ".") if (l === "..") o > 1 && o--; else break; return n.slice(0, o).join("/") + "/" + s.slice(i).join("/") } const ft = { path: "/", name: void 0, params: {}, query: {}, hash: "", fullPath: "/", matched: [], meta: {}, redirectedFrom: void 0 }; let Cs = (function (e) { return e.pop = "pop", e.push = "push", e })({}), hs = (function (e) { return e.back = "back", e.forward = "forward", e.unknown = "", e })({}); function aa(e) { if (!e) if (Lt) { const t = document.querySelector("base"); e = t && t.getAttribute("href") || "/", e = e.replace(/^\w+:\/\/[^\/]+/, "") } else e = "/"; return e[0] !== "/" && e[0] !== "#" && (e = "/" + e), ra(e) } const ua = /^[^#]+#/; function fa(e, t) { return e.replace(ua, "#") + t } function da(e, t) { const n = document.documentElement.getBoundingClientRect(), s = e.getBoundingClientRect(); return { behavior: t.behavior, left: s.left - n.left - (t.left || 0), top: s.top - n.top - (t.top || 0) } } const es = () => ({ left: window.scrollX, top: window.scrollY }); function ha(e) { let t; if ("el" in e) { const n = e.el, s = typeof n == "string" && n.startsWith("#"), r = typeof n == "string" ? s ? document.getElementById(n.slice(1)) : document.querySelector(n) : n; if (!r) return; t = da(r, e) } else t = e; "scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY) } function Nr(e, t) { return (history.state ? history.state.position - t : -1) + e } const Os = new Map; function pa(e, t) { Os.set(e, t) } function ga(e) { const t = Os.get(e); return Os.delete(e), t } function ma(e) { return typeof e == "string" || e && typeof e == "object" } function li(e) { return typeof e == "string" || typeof e == "symbol" } let le = (function (e) { return e[e.MATCHER_NOT_FOUND = 1] = "MATCHER_NOT_FOUND", e[e.NAVIGATION_GUARD_REDIRECT = 2] = "NAVIGATION_GUARD_REDIRECT", e[e.NAVIGATION_ABORTED = 4] = "NAVIGATION_ABORTED", e[e.NAVIGATION_CANCELLED = 8] = "NAVIGATION_CANCELLED", e[e.NAVIGATION_DUPLICATED = 16] = "NAVIGATION_DUPLICATED", e })({}); const ci = Symbol(""); le.MATCHER_NOT_FOUND + "", le.NAVIGATION_GUARD_REDIRECT + "", le.NAVIGATION_ABORTED + "", le.NAVIGATION_CANCELLED + "", le.NAVIGATION_DUPLICATED + ""; function qt(e, t) { return J(new Error, { type: e, [ci]: !0 }, t) } function et(e, t) { return e instanceof Error && ci in e && (t == null || !!(e.type & t)) } const _a = ["params", "query", "hash"]; function ya(e) { if (typeof e == "string") return e; if (e.path != null) return e.path; const t = {}; for (const n of _a) n in e && (t[n] = e[n]); return JSON.stringify(t, null, 2) } function va(e) { const t = {}; if (e === "" || e === "?") return t; const n = (e[0] === "?" ? e.slice(1) : e).split("&"); for (let s = 0; s < n.length; ++s) { const r = n[s].replace(ni, " "), o = r.indexOf("="), i = mn(o < 0 ? r : r.slice(0, o)), l = o < 0 ? null : mn(r.slice(o + 1)); if (i in t) { let c = t[i]; He(c) || (c = t[i] = [c]), c.push(l) } else t[i] = l } return t } function Dr(e) { let t = ""; for (let n in e) { const s = e[n]; if (n = ea(n), s == null) { s !== void 0 && (t += (t.length ? "&" : "") + n); continue } (He(s) ? s.map(r => r && Ps(r)) : [s && Ps(s)]).forEach(r => { r !== void 0 && (t += (t.length ? "&" : "") + n, r != null && (t += "=" + r)) }) } return t } function ba(e) { const t = {}; for (const n in e) { const s = e[n]; s !== void 0 && (t[n] = He(s) ? s.map(r => r == null ? null : "" + r) : s == null ? s : "" + s) } return t } const xa = Symbol(""), Mr = Symbol(""), Ys = Symbol(""), ai = Symbol(""), Ts = Symbol(""); function Xt() { let e = []; function t(s) { return e.push(s), () => { const r = e.indexOf(s); r > -1 && e.splice(r, 1) } } function n() { e = [] } return { add: t, list: () => e.slice(), reset: n } } function gt(e, t, n, s, r, o = i => i()) { const i = s && (s.enterCallbacks[r] = s.enterCallbacks[r] || []); return () => new Promise((l, c) => { const h = p => { p === !1 ? c(qt(le.NAVIGATION_ABORTED, { from: n, to: t })) : p instanceof Error ? c(p) : ma(p) ? c(qt(le.NAVIGATION_GUARD_REDIRECT, { from: t, to: p })) : (i && s.enterCallbacks[r] === i && typeof p == "function" && i.push(p), l()) }, a = o(() => e.call(s && s.instances[r], t, n, h)); let f = Promise.resolve(a); e.length < 3 && (f = f.then(h)), f.catch(p => c(p)) }) } function ps(e, t, n, s, r = o => o()) { const o = []; for (const i of e) for (const l in i.components) { let c = i.components[l]; if (!(t !== "beforeRouteEnter" && !i.instances[l])) if (ei(c)) { const h = (c.__vccOpts || c)[t]; h && o.push(gt(h, n, s, i, l, r)) } else { let h = c(); o.push(() => h.then(a => { if (!a) throw new Error(`Couldn't resolve component "${l}" at "${i.path}"`); const f = kc(a) ? a.default : a; i.mods[l] = a, i.components[l] = f; const p = (f.__vccOpts || f)[t]; return p && gt(p, n, s, i, l, r)() })) } } return o } function Ea(e, t) { const n = [], s = [], r = [], o = Math.max(t.matched.length, e.matched.length); for (let i = 0; i < o; i++) { const l = t.matched[i]; l && (e.matched.find(h => Wt(h, l)) ? s.push(l) : n.push(l)); const c = e.matched[i]; c && (t.matched.find(h => Wt(h, c)) || r.push(c)) } return [n, s, r] }/*!
 * vue-router v4.6.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */let wa = () => location.protocol + "//" + location.host; function ui(e, t) { const { pathname: n, search: s, hash: r } = t, o = e.indexOf("#"); if (o > -1) { let i = r.includes(e.slice(o)) ? e.slice(o).length : 1, l = r.slice(i); return l[0] !== "/" && (l = "/" + l), Tr(l, "") } return Tr(n, e) + s + r } function Aa(e, t, n, s) { let r = [], o = [], i = null; const l = ({ state: p }) => { const m = ui(e, location), _ = n.value, T = t.value; let H = 0; if (p) { if (n.value = m, t.value = p, i && i === _) { i = null; return } H = T ? p.position - T.position : 0 } else s(m); r.forEach(w => { w(n.value, _, { delta: H, type: Cs.pop, direction: H ? H > 0 ? hs.forward : hs.back : hs.unknown }) }) }; function c() { i = n.value } function h(p) { r.push(p); const m = () => { const _ = r.indexOf(p); _ > -1 && r.splice(_, 1) }; return o.push(m), m } function a() { if (document.visibilityState === "hidden") { const { history: p } = window; if (!p.state) return; p.replaceState(J({}, p.state, { scroll: es() }), "") } } function f() { for (const p of o) p(); o = [], window.removeEventListener("popstate", l), window.removeEventListener("pagehide", a), document.removeEventListener("visibilitychange", a) } return window.addEventListener("popstate", l), window.addEventListener("pagehide", a), document.addEventListener("visibilitychange", a), { pauseListeners: c, listen: h, destroy: f } } function Br(e, t, n, s = !1, r = !1) { return { back: e, current: t, forward: n, replaced: s, position: window.history.length, scroll: r ? es() : null } } function Ra(e) { const { history: t, location: n } = window, s = { value: ui(e, n) }, r = { value: t.state }; r.value || o(s.value, { back: null, current: s.value, forward: null, position: t.length - 1, replaced: !0, scroll: null }, !0); function o(c, h, a) { const f = e.indexOf("#"), p = f > -1 ? (n.host && document.querySelector("base") ? e : e.slice(f)) + c : wa() + e + c; try { t[a ? "replaceState" : "pushState"](h, "", p), r.value = h } catch (m) { console.error(m), n[a ? "replace" : "assign"](p) } } function i(c, h) { o(c, J({}, t.state, Br(r.value.back, c, r.value.forward, !0), h, { position: r.value.position }), !0), s.value = c } function l(c, h) { const a = J({}, r.value, t.state, { forward: c, scroll: es() }); o(a.current, a, !0), o(c, J({}, Br(s.value, c, null), { position: a.position + 1 }, h), !1), s.value = c } return { location: s, state: r, push: l, replace: i } } function Sa(e) { e = aa(e); const t = Ra(e), n = Aa(e, t.state, t.location, t.replace); function s(o, i = !0) { i || n.pauseListeners(), history.go(o) } const r = J({ location: "", base: e, go: s, createHref: fa.bind(null, e) }, t, n); return Object.defineProperty(r, "location", { enumerable: !0, get: () => t.location.value }), Object.defineProperty(r, "state", { enumerable: !0, get: () => t.state.value }), r } let Ct = (function (e) { return e[e.Static = 0] = "Static", e[e.Param = 1] = "Param", e[e.Group = 2] = "Group", e })({}); var fe = (function (e) { return e[e.Static = 0] = "Static", e[e.Param = 1] = "Param", e[e.ParamRegExp = 2] = "ParamRegExp", e[e.ParamRegExpEnd = 3] = "ParamRegExpEnd", e[e.EscapeNext = 4] = "EscapeNext", e })(fe || {}); const Pa = { type: Ct.Static, value: "" }, Ca = /[a-zA-Z0-9_]/; function Oa(e) { if (!e) return [[]]; if (e === "/") return [[Pa]]; if (!e.startsWith("/")) throw new Error(`Invalid path "${e}"`); function t(m) { throw new Error(`ERR (${n})/"${h}": ${m}`) } let n = fe.Static, s = n; const r = []; let o; function i() { o && r.push(o), o = [] } let l = 0, c, h = "", a = ""; function f() { h && (n === fe.Static ? o.push({ type: Ct.Static, value: h }) : n === fe.Param || n === fe.ParamRegExp || n === fe.ParamRegExpEnd ? (o.length > 1 && (c === "*" || c === "+") && t(`A repeatable param (${h}) must be alone in its segment. eg: '/:ids+.`), o.push({ type: Ct.Param, value: h, regexp: a, repeatable: c === "*" || c === "+", optional: c === "*" || c === "?" })) : t("Invalid state to consume buffer"), h = "") } function p() { h += c } for (; l < e.length;) { if (c = e[l++], c === "\\" && n !== fe.ParamRegExp) { s = n, n = fe.EscapeNext; continue } switch (n) { case fe.Static: c === "/" ? (h && f(), i()) : c === ":" ? (f(), n = fe.Param) : p(); break; case fe.EscapeNext: p(), n = s; break; case fe.Param: c === "(" ? n = fe.ParamRegExp : Ca.test(c) ? p() : (f(), n = fe.Static, c !== "*" && c !== "?" && c !== "+" && l--); break; case fe.ParamRegExp: c === ")" ? a[a.length - 1] == "\\" ? a = a.slice(0, -1) + c : n = fe.ParamRegExpEnd : a += c; break; case fe.ParamRegExpEnd: f(), n = fe.Static, c !== "*" && c !== "?" && c !== "+" && l--, a = ""; break; default: t("Unknown state"); break } } return n === fe.ParamRegExp && t(`Unfinished custom RegExp for param "${h}"`), f(), i(), r } const $r = "[^/]+?", Ta = { sensitive: !1, strict: !1, start: !0, end: !0 }; var be = (function (e) { return e[e._multiplier = 10] = "_multiplier", e[e.Root = 90] = "Root", e[e.Segment = 40] = "Segment", e[e.SubSegment = 30] = "SubSegment", e[e.Static = 40] = "Static", e[e.Dynamic = 20] = "Dynamic", e[e.BonusCustomRegExp = 10] = "BonusCustomRegExp", e[e.BonusWildcard = -50] = "BonusWildcard", e[e.BonusRepeatable = -20] = "BonusRepeatable", e[e.BonusOptional = -8] = "BonusOptional", e[e.BonusStrict = .7000000000000001] = "BonusStrict", e[e.BonusCaseSensitive = .25] = "BonusCaseSensitive", e })(be || {}); const Ia = /[.+*?^${}()[\]/\\]/g; function Na(e, t) { const n = J({}, Ta, t), s = []; let r = n.start ? "^" : ""; const o = []; for (const h of e) { const a = h.length ? [] : [be.Root]; n.strict && !h.length && (r += "/"); for (let f = 0; f < h.length; f++) { const p = h[f]; let m = be.Segment + (n.sensitive ? be.BonusCaseSensitive : 0); if (p.type === Ct.Static) f || (r += "/"), r += p.value.replace(Ia, "\\$&"), m += be.Static; else if (p.type === Ct.Param) { const { value: _, repeatable: T, optional: H, regexp: w } = p; o.push({ name: _, repeatable: T, optional: H }); const A = w || $r; if (A !== $r) { m += be.BonusCustomRegExp; try { `${A}` } catch (R) { throw new Error(`Invalid custom RegExp for param "${_}" (${A}): ` + R.message) } } let N = T ? `((?:${A})(?:/(?:${A}))*)` : `(${A})`; f || (N = H && h.length < 2 ? `(?:/${N})` : "/" + N), H && (N += "?"), r += N, m += be.Dynamic, H && (m += be.BonusOptional), T && (m += be.BonusRepeatable), A === ".*" && (m += be.BonusWildcard) } a.push(m) } s.push(a) } if (n.strict && n.end) { const h = s.length - 1; s[h][s[h].length - 1] += be.BonusStrict } n.strict || (r += "/?"), n.end ? r += "$" : n.strict && !r.endsWith("/") && (r += "(?:/|$)"); const i = new RegExp(r, n.sensitive ? "" : "i"); function l(h) { const a = h.match(i), f = {}; if (!a) return null; for (let p = 1; p < a.length; p++) { const m = a[p] || "", _ = o[p - 1]; f[_.name] = m && _.repeatable ? m.split("/") : m } return f } function c(h) { let a = "", f = !1; for (const p of e) { (!f || !a.endsWith("/")) && (a += "/"), f = !1; for (const m of p) if (m.type === Ct.Static) a += m.value; else if (m.type === Ct.Param) { const { value: _, repeatable: T, optional: H } = m, w = _ in h ? h[_] : ""; if (He(w) && !T) throw new Error(`Provided param "${_}" is an array but it is not repeatable (* or + modifiers)`); const A = He(w) ? w.join("/") : w; if (!A) if (H) p.length < 2 && (a.endsWith("/") ? a = a.slice(0, -1) : f = !0); else throw new Error(`Missing required param "${_}"`); a += A } } return a || "/" } return { re: i, score: s, keys: o, parse: l, stringify: c } } function Da(e, t) { let n = 0; for (; n < e.length && n < t.length;) { const s = t[n] - e[n]; if (s) return s; n++ } return e.length < t.length ? e.length === 1 && e[0] === be.Static + be.Segment ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === be.Static + be.Segment ? 1 : -1 : 0 } function fi(e, t) { let n = 0; const s = e.score, r = t.score; for (; n < s.length && n < r.length;) { const o = Da(s[n], r[n]); if (o) return o; n++ } if (Math.abs(r.length - s.length) === 1) { if (Lr(s)) return 1; if (Lr(r)) return -1 } return r.length - s.length } function Lr(e) { const t = e[e.length - 1]; return e.length > 0 && t[t.length - 1] < 0 } const Ma = { strict: !1, end: !0, sensitive: !1 }; function Ba(e, t, n) { const s = Na(Oa(e.path), n), r = J(s, { record: e, parent: t, children: [], alias: [] }); return t && !r.record.aliasOf == !t.record.aliasOf && t.children.push(r), r } function $a(e, t) { const n = [], s = new Map; t = Or(Ma, t); function r(f) { return s.get(f) } function o(f, p, m) { const _ = !m, T = Vr(f); T.aliasOf = m && m.record; const H = Or(t, f), w = [T]; if ("alias" in f) { const R = typeof f.alias == "string" ? [f.alias] : f.alias; for (const V of R) w.push(Vr(J({}, T, { components: m ? m.record.components : T.components, path: V, aliasOf: m ? m.record : T }))) } let A, N; for (const R of w) { const { path: V } = R; if (p && V[0] !== "/") { const B = p.record.path, K = B[B.length - 1] === "/" ? "" : "/"; R.path = p.record.path + (V && K + V) } if (A = Ba(R, p, H), m ? m.alias.push(A) : (N = N || A, N !== A && N.alias.push(A), _ && f.name && !Hr(A) && i(f.name)), di(A) && c(A), T.children) { const B = T.children; for (let K = 0; K < B.length; K++)o(B[K], A, m && m.children[K]) } m = m || A } return N ? () => { i(N) } : cn } function i(f) { if (li(f)) { const p = s.get(f); p && (s.delete(f), n.splice(n.indexOf(p), 1), p.children.forEach(i), p.alias.forEach(i)) } else { const p = n.indexOf(f); p > -1 && (n.splice(p, 1), f.record.name && s.delete(f.record.name), f.children.forEach(i), f.alias.forEach(i)) } } function l() { return n } function c(f) { const p = Va(f, n); n.splice(p, 0, f), f.record.name && !Hr(f) && s.set(f.record.name, f) } function h(f, p) { let m, _ = {}, T, H; if ("name" in f && f.name) { if (m = s.get(f.name), !m) throw qt(le.MATCHER_NOT_FOUND, { location: f }); H = m.record.name, _ = J(Fr(p.params, m.keys.filter(N => !N.optional).concat(m.parent ? m.parent.keys.filter(N => N.optional) : []).map(N => N.name)), f.params && Fr(f.params, m.keys.map(N => N.name))), T = m.stringify(_) } else if (f.path != null) T = f.path, m = n.find(N => N.re.test(T)), m && (_ = m.parse(T), H = m.record.name); else { if (m = p.name ? s.get(p.name) : n.find(N => N.re.test(p.path)), !m) throw qt(le.MATCHER_NOT_FOUND, { location: f, currentLocation: p }); H = m.record.name, _ = J({}, p.params, f.params), T = m.stringify(_) } const w = []; let A = m; for (; A;)w.unshift(A.record), A = A.parent; return { name: H, path: T, params: _, matched: w, meta: Fa(w) } } e.forEach(f => o(f)); function a() { n.length = 0, s.clear() } return { addRoute: o, resolve: h, removeRoute: i, clearRoutes: a, getRoutes: l, getRecordMatcher: r } } function Fr(e, t) { const n = {}; for (const s of t) s in e && (n[s] = e[s]); return n } function Vr(e) { const t = { path: e.path, redirect: e.redirect, name: e.name, meta: e.meta || {}, aliasOf: e.aliasOf, beforeEnter: e.beforeEnter, props: La(e), children: e.children || [], instances: {}, leaveGuards: new Set, updateGuards: new Set, enterCallbacks: {}, components: "components" in e ? e.components || null : e.component && { default: e.component } }; return Object.defineProperty(t, "mods", { value: {} }), t } function La(e) { const t = {}, n = e.props || !1; if ("component" in e) t.default = n; else for (const s in e.components) t[s] = typeof n == "object" ? n[s] : n; return t } function Hr(e) { for (; e;) { if (e.record.aliasOf) return !0; e = e.parent } return !1 } function Fa(e) { return e.reduce((t, n) => J(t, n.meta), {}) } function Va(e, t) { let n = 0, s = t.length; for (; n !== s;) { const o = n + s >> 1; fi(e, t[o]) < 0 ? s = o : n = o + 1 } const r = Ha(e); return r && (s = t.lastIndexOf(r, s - 1)), s } function Ha(e) { let t = e; for (; t = t.parent;)if (di(t) && fi(e, t) === 0) return t } function di({ record: e }) { return !!(e.name || e.components && Object.keys(e.components).length || e.redirect) } function jr(e) { const t = ot(Ys), n = ot(ai), s = ae(() => { const c = Ut(e.to); return t.resolve(c) }), r = ae(() => { const { matched: c } = s.value, { length: h } = c, a = c[h - 1], f = n.matched; if (!a || !f.length) return -1; const p = f.findIndex(Wt.bind(null, a)); if (p > -1) return p; const m = Ur(c[h - 2]); return h > 1 && Ur(a) === m && f[f.length - 1].path !== m ? f.findIndex(Wt.bind(null, c[h - 2])) : p }), o = ae(() => r.value > -1 && Ga(n.params, s.value.params)), i = ae(() => r.value > -1 && r.value === n.matched.length - 1 && ii(n.params, s.value.params)); function l(c = {}) { if (Ka(c)) { const h = t[Ut(e.replace) ? "replace" : "push"](Ut(e.to)).catch(cn); return e.viewTransition && typeof document < "u" && "startViewTransition" in document && document.startViewTransition(() => h), h } return Promise.resolve() } return { route: s, href: ae(() => s.value.href), isActive: o, isExactActive: i, navigate: l } } function ja(e) { return e.length === 1 ? e[0] : e } const Ua = wo({ name: "RouterLink", compatConfig: { MODE: 3 }, props: { to: { type: [String, Object], required: !0 }, replace: Boolean, activeClass: String, exactActiveClass: String, custom: Boolean, ariaCurrentValue: { type: String, default: "page" }, viewTransition: Boolean }, useLink: jr, setup(e, { slots: t }) { const n = yn(jr(e)), { options: s } = ot(Ys), r = ae(() => ({ [kr(e.activeClass, s.linkActiveClass, "router-link-active")]: n.isActive, [kr(e.exactActiveClass, s.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive })); return () => { const o = t.default && ja(t.default(n)); return e.custom ? o : Qo("a", { "aria-current": n.isExactActive ? e.ariaCurrentValue : null, href: n.href, onClick: n.navigate, class: r.value }, o) } } }), ka = Ua; function Ka(e) { if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) { if (e.currentTarget && e.currentTarget.getAttribute) { const t = e.currentTarget.getAttribute("target"); if (/\b_blank\b/i.test(t)) return } return e.preventDefault && e.preventDefault(), !0 } } function Ga(e, t) { for (const n in t) { const s = t[n], r = e[n]; if (typeof s == "string") { if (s !== r) return !1 } else if (!He(r) || r.length !== s.length || s.some((o, i) => o !== r[i])) return !1 } return !0 } function Ur(e) { return e ? e.aliasOf ? e.aliasOf.path : e.path : "" } const kr = (e, t, n) => e ?? t ?? n, Wa = wo({ name: "RouterView", inheritAttrs: !1, props: { name: { type: String, default: "default" }, route: Object }, compatConfig: { MODE: 3 }, setup(e, { attrs: t, slots: n }) { const s = ot(Ts), r = ae(() => e.route || s.value), o = ot(Mr, 0), i = ae(() => { let h = Ut(o); const { matched: a } = r.value; let f; for (; (f = a[h]) && !f.components;)h++; return h }), l = ae(() => r.value.matched[i.value]); Pn(Mr, ae(() => i.value + 1)), Pn(xa, l), Pn(Ts, r); const c = Ft(); return Cn(() => [c.value, l.value, e.name], ([h, a, f], [p, m, _]) => { a && (a.instances[f] = h, m && m !== a && h && h === p && (a.leaveGuards.size || (a.leaveGuards = m.leaveGuards), a.updateGuards.size || (a.updateGuards = m.updateGuards))), h && a && (!m || !Wt(a, m) || !p) && (a.enterCallbacks[f] || []).forEach(T => T(h)) }, { flush: "post" }), () => { const h = r.value, a = e.name, f = l.value, p = f && f.components[a]; if (!p) return Kr(n.default, { Component: p, route: h }); const m = f.props[a], _ = m ? m === !0 ? h.params : typeof m == "function" ? m(h) : m : null, H = Qo(p, J({}, _, t, { onVnodeUnmounted: w => { w.component.isUnmounted && (f.instances[a] = null) }, ref: c })); return Kr(n.default, { Component: H, route: h }) || H } } }); function Kr(e, t) { if (!e) return null; const n = e(t); return n.length === 1 ? n[0] : n } const qa = Wa; function za(e) { const t = $a(e.routes, e), n = e.parseQuery || va, s = e.stringifyQuery || Dr, r = e.history, o = Xt(), i = Xt(), l = Xt(), c = qi(ft); let h = ft; Lt && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual"); const a = fs.bind(null, b => "" + b), f = fs.bind(null, na), p = fs.bind(null, mn); function m(b, M) { let I, $; return li(b) ? (I = t.getRecordMatcher(b), $ = M) : $ = b, t.addRoute($, I) } function _(b) { const M = t.getRecordMatcher(b); M && t.removeRoute(M) } function T() { return t.getRoutes().map(b => b.record) } function H(b) { return !!t.getRecordMatcher(b) } function w(b, M) { if (M = J({}, M || c.value), typeof b == "string") { const g = ds(n, b, M.path), v = t.resolve({ path: g.path }, M), x = r.createHref(g.fullPath); return J(g, v, { params: p(v.params), hash: mn(g.hash), redirectedFrom: void 0, href: x }) } let I; if (b.path != null) I = J({}, b, { path: ds(n, b.path, M.path).path }); else { const g = J({}, b.params); for (const v in g) g[v] == null && delete g[v]; I = J({}, b, { params: f(g) }), M.params = f(M.params) } const $ = t.resolve(I, M), G = b.hash || ""; $.params = a(p($.params)); const u = oa(s, J({}, b, { hash: Zc(G), path: $.path })), d = r.createHref(u); return J({ fullPath: u, hash: G, query: s === Dr ? ba(b.query) : b.query || {} }, $, { redirectedFrom: void 0, href: d }) } function A(b) { return typeof b == "string" ? ds(n, b, c.value.path) : J({}, b) } function N(b, M) { if (h !== b) return qt(le.NAVIGATION_CANCELLED, { from: M, to: b }) } function R(b) { return K(b) } function V(b) { return R(J(A(b), { replace: !0 })) } function B(b, M) { const I = b.matched[b.matched.length - 1]; if (I && I.redirect) { const { redirect: $ } = I; let G = typeof $ == "function" ? $(b, M) : $; return typeof G == "string" && (G = G.includes("?") || G.includes("#") ? G = A(G) : { path: G }, G.params = {}), J({ query: b.query, hash: b.hash, params: G.path != null ? {} : b.params }, G) } } function K(b, M) { const I = h = w(b), $ = c.value, G = b.state, u = b.force, d = b.replace === !0, g = B(I, $); if (g) return K(J(A(g), { state: typeof g == "object" ? J({}, G, g.state) : G, force: u, replace: d }), M || I); const v = I; v.redirectedFrom = M; let x; return !u && ia(s, $, I) && (x = qt(le.NAVIGATION_DUPLICATED, { to: v, from: $ }), je($, $, !0, !1)), (x ? Promise.resolve(x) : Ee(v, $)).catch(y => et(y) ? et(y, le.NAVIGATION_GUARD_REDIRECT) ? y : ut(y) : Y(y, v, $)).then(y => { if (y) { if (et(y, le.NAVIGATION_GUARD_REDIRECT)) return K(J({ replace: d }, A(y.to), { state: typeof y.to == "object" ? J({}, G, y.to.state) : G, force: u }), M || v) } else y = Qe(v, $, !0, d, G); return Ie(v, $, y), y }) } function ee(b, M) { const I = N(b, M); return I ? Promise.reject(I) : Promise.resolve() } function Te(b) { const M = It.values().next().value; return M && typeof M.runWithContext == "function" ? M.runWithContext(b) : b() } function Ee(b, M) { let I; const [$, G, u] = Ea(b, M); I = ps($.reverse(), "beforeRouteLeave", b, M); for (const g of $) g.leaveGuards.forEach(v => { I.push(gt(v, b, M)) }); const d = ee.bind(null, b, M); return I.push(d), De(I).then(() => { I = []; for (const g of o.list()) I.push(gt(g, b, M)); return I.push(d), De(I) }).then(() => { I = ps(G, "beforeRouteUpdate", b, M); for (const g of G) g.updateGuards.forEach(v => { I.push(gt(v, b, M)) }); return I.push(d), De(I) }).then(() => { I = []; for (const g of u) if (g.beforeEnter) if (He(g.beforeEnter)) for (const v of g.beforeEnter) I.push(gt(v, b, M)); else I.push(gt(g.beforeEnter, b, M)); return I.push(d), De(I) }).then(() => (b.matched.forEach(g => g.enterCallbacks = {}), I = ps(u, "beforeRouteEnter", b, M, Te), I.push(d), De(I))).then(() => { I = []; for (const g of i.list()) I.push(gt(g, b, M)); return I.push(d), De(I) }).catch(g => et(g, le.NAVIGATION_CANCELLED) ? g : Promise.reject(g)) } function Ie(b, M, I) { l.list().forEach($ => Te(() => $(b, M, I))) } function Qe(b, M, I, $, G) { const u = N(b, M); if (u) return u; const d = M === ft, g = Lt ? history.state : {}; I && ($ || d ? r.replace(b.fullPath, J({ scroll: d && g && g.scroll }, G)) : r.push(b.fullPath, G)), c.value = b, je(b, M, I, d), ut() } let Ne; function Et() { Ne || (Ne = r.listen((b, M, I) => { if (!wt.listening) return; const $ = w(b), G = B($, wt.currentRoute.value); if (G) { K(J(G, { replace: !0, force: !0 }), $).catch(cn); return } h = $; const u = c.value; Lt && pa(Nr(u.fullPath, I.delta), es()), Ee($, u).catch(d => et(d, le.NAVIGATION_ABORTED | le.NAVIGATION_CANCELLED) ? d : et(d, le.NAVIGATION_GUARD_REDIRECT) ? (K(J(A(d.to), { force: !0 }), $).then(g => { et(g, le.NAVIGATION_ABORTED | le.NAVIGATION_DUPLICATED) && !I.delta && I.type === Cs.pop && r.go(-1, !1) }).catch(cn), Promise.reject()) : (I.delta && r.go(-I.delta, !1), Y(d, $, u))).then(d => { d = d || Qe($, u, !1), d && (I.delta && !et(d, le.NAVIGATION_CANCELLED) ? r.go(-I.delta, !1) : I.type === Cs.pop && et(d, le.NAVIGATION_ABORTED | le.NAVIGATION_DUPLICATED) && r.go(-1, !1)), Ie($, u, d) }).catch(cn) })) } let at = Xt(), de = Xt(), ne; function Y(b, M, I) { ut(b); const $ = de.list(); return $.length ? $.forEach(G => G(b, M, I)) : console.error(b), Promise.reject(b) } function Xe() { return ne && c.value !== ft ? Promise.resolve() : new Promise((b, M) => { at.add([b, M]) }) } function ut(b) { return ne || (ne = !b, Et(), at.list().forEach(([M, I]) => b ? I(b) : M()), at.reset()), b } function je(b, M, I, $) { const { scrollBehavior: G } = e; if (!Lt || !G) return Promise.resolve(); const u = !I && ga(Nr(b.fullPath, 0)) || ($ || !I) && history.state && history.state.scroll || null; return Bn().then(() => G(b, M, u)).then(d => d && ha(d)).catch(d => Y(d, b, M)) } const we = b => r.go(b); let Tt; const It = new Set, wt = { currentRoute: c, listening: !0, addRoute: m, removeRoute: _, clearRoutes: t.clearRoutes, hasRoute: H, getRoutes: T, resolve: w, options: e, push: R, replace: V, go: we, back: () => we(-1), forward: () => we(1), beforeEach: o.add, beforeResolve: i.add, afterEach: l.add, onError: de.add, isReady: Xe, install(b) { b.component("RouterLink", ka), b.component("RouterView", qa), b.config.globalProperties.$router = wt, Object.defineProperty(b.config.globalProperties, "$route", { enumerable: !0, get: () => Ut(c) }), Lt && !Tt && c.value === ft && (Tt = !0, R(r.location).catch($ => { })); const M = {}; for (const $ in ft) Object.defineProperty(M, $, { get: () => c.value[$], enumerable: !0 }); b.provide(Ys, wt), b.provide(ai, go(M)), b.provide(Ts, c); const I = b.unmount; It.add(b), b.unmount = function () { It.delete(b), It.size < 1 && (h = ft, Ne && Ne(), Ne = null, c.value = ft, Tt = !1, ne = !1), I() } } }; function De(b) { return b.reduce((M, I) => M.then(() => Te(I)), Promise.resolve()) } return wt } const Ya = { class: "kanban-board", role: "application", "aria-label": "Quadro Kanban de tarefas", "aria-describedby": "board-instructions" }, Ja = { "aria-live": "polite", "aria-atomic": "true", class: "sr-only", role: "status" }, Qa = ["aria-labelledby"], Xa = ["id"], Za = { class: "task-count" }, eu = ["aria-label", "onDragover", "onDrop"], tu = ["aria-label", "aria-describedby", "aria-grabbed", "data-card-id", "onKeyup", "onKeydown", "onDragstart"], nu = { class: "card-title" }, su = ["id"], ru = ["aria-label"], ou = { "aria-hidden": "true" }, iu = { key: 0, title: "Prioridade Alta" }, lu = { key: 1, title: "Prioridade Mdia" }, cu = { key: 2, title: "Prioridade Baixa" }, au = { class: "sr-only" }, uu = { class: "navigation-footer" }, fu = { __name: "KanbanView", setup(e) { const t = yn([{ id: "todo", title: "A Fazer", tasks: [{ id: "t1", title: "Analisar requisitos do Relatrio de Vendas", description: "Definir KPIs e mtricas com a equipe de produto.", priority: "Alta" }, { id: "t2", title: "Modelar esquema do banco de dados", description: "Criar tabelas para armazenar os dados de vendas agregados.", priority: "Alta" }, { id: "t5", title: "Configurar job de processamento noturno", description: "Desenvolver script para consolidar os dados diariamente.", priority: "Mdia" }, { id: "t8", title: "Criar documentao inicial da API", description: "Esboar os endpoints no Swagger/OpenAPI.", priority: "Baixa" }] }, { id: "progress", title: "Em Progresso", tasks: [{ id: "t3", title: "Desenvolver API de dados do relatrio", description: "Endpoints para consulta de vendas por perodo e produto.", priority: "Alta" }, { id: "t6", title: "Criar componente de grfico de barras", description: "Componente Vue reutilizvel para exibir os dados.", priority: "Mdia" }] }, { id: "testing", title: "Em Teste", tasks: [{ id: "t4", title: "Implementar UI da pgina de relatrios", description: "Layout responsivo com filtros de data.", priority: "Alta" }, { id: "t9", title: "Testar performance da consulta principal", description: "Verificar tempo de resposta com 1 milho de registros.", priority: "Mdia" }, { id: "t10", title: "Reviso de acessibilidade da nova pgina", description: "Garantir conformidade com WCAG 2.1 e testes com NVDA.", priority: "Alta" }] }, { id: "done", title: "Concludo", tasks: [{ id: "t7", title: "Setup inicial do projeto", description: "Configurao de repositrio, CI/CD e dependncias.", priority: "Baixa" }, { id: "t11", title: "Aprovao do layout no Figma", description: "UI/UX finalizado e aprovado pela equipe de design.", priority: "Baixa" }] }]), n = Ft(null), s = Ft(""), r = Ft(null), o = Ft(null); function i(w) { s.value = "", Bn(() => { s.value = w }) } function l(w) { n.value?.id === w.id ? (n.value = null, i(`Modo de movimento desativado para '${w.title}'.`)) : (n.value = w, i(`'${w.title}' selecionado. Use as setas para mover ou Escape para cancelar.`)) } function c(w, A, N) { if (A === N) return; const R = t.find(ee => ee.id === A), V = t.find(ee => ee.id === N); if (!R || !V) return; const B = R.tasks.findIndex(ee => ee.id === w); if (B === -1) return; const [K] = R.tasks.splice(B, 1); V.tasks.push(K), i(`Tarefa '${K.title}' movida para ${V.title}.`) } function h(w, A, N, R) { const V = t.find(ee => ee.id === A); if (!V) return; const B = N + R, [K] = V.tasks.splice(N, 1); V.tasks.splice(B, 0, K), i(`'${K.title}' movido para a posio ${B + 1}.`) } async function a(w, A, N, R, V) { if (!n.value || n.value.id !== A.id) return; const B = async () => { await Bn(); const K = document.querySelector(`[data-card-id="${A.id}"]`); K && K.focus() }; switch (w.code) { case "ArrowRight": w.preventDefault(), R < t.length - 1 && (c(A.id, N, t[R + 1].id), B()); break; case "ArrowLeft": w.preventDefault(), R > 0 && (c(A.id, N, t[R - 1].id), B()); break; case "ArrowUp": w.preventDefault(), V > 0 && (h(A.id, N, V, -1), B()); break; case "ArrowDown": w.preventDefault(), V < t.length - 1 && (h(A.id, N, V, 1), B()); break; case "Escape": w.preventDefault(); const K = n.value.title; n.value = null, i(`Seleo de '${K}' cancelada.`); break } } function f(w, A) { w.dataTransfer.setData("text/plain", A.id), w.dataTransfer.dropEffect = "move", r.value = A.id } function p(w) { o.value = w.id } function m() { o.value = null } function _(w) { const A = event.dataTransfer.getData("text/plain"); let N = null; for (const R of t) if (R.tasks.some(V => V.id === A)) { N = R; break } N && w && c(A, N.id, w.id), H() } function T() { H() } function H() { r.value = null, o.value = null } return (w, A) => { const N = Qn("router-link"); return z(), Z(ce, null, [S("div", Ya, [A[2] || (A[2] = S("div", { id: "board-instructions", class: "sr-only" }, [S("h2", null, "Instrues do Quadro Kanban:"), S("ul", null, [S("li", null, "Use Tab para navegar entre os cartes."), S("li", null, "Pressione Enter ou Espao em um carto para ativar o modo de movimento."), S("li", null, "Com o modo de movimento ativo, use as setas direcionais para mover o carto entre ou dentro das colunas."), S("li", null, "Pressione Escape para desativar o modo de movimento."), S("li", null, "Alternativamente, use o mouse para arrastar e soltar os cartes entre as colunas.")])], -1)), S("div", Ja, q(s.value), 1), (z(!0), Z(ce, null, ze(t, (R, V) => (z(), Z("section", { key: R.id, class: "kanban-column", "aria-labelledby": `title-${R.id}` }, [S("h2", { id: `title-${R.id}`, class: "column-title" }, [pn(q(R.title) + " ", 1), S("span", Za, " (" + q(R.tasks.length) + ") ", 1)], 8, Xa), S("ul", { class: an(["column-content", { "drag-over": o.value === R.id }]), "aria-label": `Lista de tarefas na coluna ${R.title}`, onDragover: Qt(B => p(R), ["prevent"]), onDragleave: A[1] || (A[1] = Qt(B => m(), ["prevent"])), onDrop: Qt(B => _(R), ["prevent"]) }, [(z(!0), Z(ce, null, ze(R.tasks, (B, K) => (z(), Z("li", { key: B.id, class: an(["kanban-card", { "is-selected": n.value?.id === B.id, "is-dragging": r.value === B.id }]), tabindex: "0", "aria-label": `${B.title}. Prioridade: ${B.priority}`, "aria-describedby": `desc-${B.id}`, "aria-grabbed": n.value?.id === B.id, "data-card-id": B.id, draggable: "true", onKeyup: [Sr(Qt(ee => l(B), ["prevent"]), ["space"]), Sr(Qt(ee => l(B), ["prevent"]), ["enter"])], onKeydown: ee => a(ee, B, R.id, V, K), onDragstart: ee => f(ee, B), onDragend: A[0] || (A[0] = ee => T()) }, [S("h3", nu, q(B.title), 1), S("p", { id: `desc-${B.id}`, class: "card-description" }, q(B.description), 9, su), S("div", { class: "card-priority", "aria-label": `Prioridade ${B.priority}` }, [S("span", ou, [B.priority === "Alta" ? (z(), Z("span", iu, "")) : B.priority === "Mdia" ? (z(), Z("span", lu, "")) : (z(), Z("span", cu, ""))]), S("span", au, "Prioridade " + q(B.priority), 1)], 8, ru)], 42, tu))), 128))], 42, eu)], 8, Qa))), 128))]), S("div", uu, [pe(N, { to: "/", class: "back-home-btn" }, { default: Yn(() => [...A[3] || (A[3] = [S("i", { class: "pi pi-home" }, null, -1), pn(" Voltar para Pgina Inicial ", -1)])]), _: 1 })])], 64) } } }, du = { class: "burndown-chart-container" }, hu = { class: "chart-wrapper" }, pu = ["viewBox"], gu = { class: "grid-lines" }, mu = ["y2"], _u = ["y1", "x2", "y2"], yu = ["y1", "x2", "y2"], vu = { class: "axis-labels y-axis" }, bu = ["x", "y"], xu = ["x", "y"], Eu = ["x", "y"], wu = ["x", "y"], Au = ["x", "y"], Ru = { class: "axis-labels x-axis" }, Su = ["x", "y"], Pu = ["transform"], Cu = ["x", "y"], Ou = ["points"], Tu = ["points"], Iu = ["cx", "cy"], Nu = { class: "tooltip" }, Du = ["x", "y"], Mu = ["x", "y"], Bu = { class: "a11y-layer" }, $u = { class: "sr-only" }, Lu = { class: "navigation-footer" }, Me = 21, gs = 7, Dt = 1e3, tt = 500, Be = 80, Mt = 60, Rn = 40, Fu = { __name: "BurndownView", setup(e) { const t = [21, 21, 18, 15, 12, 10, 6, 2], n = tt - Mt, s = Dt - Be - Rn, r = a => Be + a / gs * s, o = a => n - a / Me * n, i = ae(() => t.map((a, f) => ({ x: r(f), y: o(a), value: a }))), l = ae(() => t.map((a, f) => ({ left: r(f) / Dt * 100, top: o(a) / tt * 100, value: a }))), c = ae(() => { const a = `${r(0)},${o(Me)}`, f = `${r(gs)},${o(0)}`; return `${a} ${f}` }), h = ae(() => i.value.map(a => `${a.x},${a.y}`).join(" ")); return (a, f) => { const p = Qn("router-link"); return z(), Z(ce, null, [S("div", du, [f[2] || (f[2] = S("h3", { id: "burndown-title", class: "chart-title" }, "Burndown", -1)), f[3] || (f[3] = S("div", { id: "burndown-description", class: "sr-only" }, [S("p", null, " Burndown. Use a tecla Tab para navegar pelos pontos de dados e ouvir os valores de cada dia. ")], -1)), S("div", hu, [(z(), Z("svg", { "aria-hidden": "true", viewBox: `0 0 ${Dt} ${tt}`, xmlns: "http://www.w3.org/2000/svg", class: "burndown-svg" }, [f[0] || (f[0] = S("title", null, "Burndown", -1)), f[1] || (f[1] = S("desc", null, "Burndown mostrando o trabalho ideal (cinza) vs. o trabalho real (azul) restante.", -1)), S("g", gu, [S("line", { x1: Be, y1: "0", x2: Be, y2: tt - Mt }, null, 8, mu), S("line", { x1: Be, y1: tt - Mt, x2: Dt - Rn, y2: tt - Mt }, null, 8, _u), (z(), Z(ce, null, ze(4, m => S("line", { key: `grid-y-${m}`, x1: Be, y1: o(Me * m / 4), x2: Dt - Rn, y2: o(Me * m / 4) }, null, 8, yu)), 64))]), S("g", vu, [S("text", { x: Be - 15, y: o(Me), "text-anchor": "end", "alignment-baseline": "middle" }, q(Me), 8, bu), S("text", { x: Be - 15, y: o(Math.round(Me * .75)), "text-anchor": "end", "alignment-baseline": "middle" }, q(Math.round(Me * .75)), 9, xu), S("text", { x: Be - 15, y: o(Math.round(Me * .5)), "text-anchor": "end", "alignment-baseline": "middle" }, q(Math.round(Me * .5)), 9, Eu), S("text", { x: Be - 15, y: o(Math.round(Me * .25)), "text-anchor": "end", "alignment-baseline": "middle" }, q(Math.round(Me * .25)), 9, wu), S("text", { x: Be - 15, y: o(0), "text-anchor": "end", "alignment-baseline": "middle" }, "0", 8, Au)]), S("g", Ru, [(z(!0), Z(ce, null, ze(gs + 1, m => (z(), Z("text", { key: `label-x-${m}`, x: r(m - 1), y: tt - Mt + 25, "text-anchor": "middle" }, "Dia " + q(m - 1), 9, Su))), 128))]), S("text", { class: "axis-title", "text-anchor": "middle", transform: `translate(30, ${(tt - Mt) / 2}) rotate(-90)` }, " Tarefas Restantes ", 8, Pu), S("text", { class: "axis-title", x: (Dt + Be - Rn) / 2, y: tt - 10, "text-anchor": "middle" }, "Dias do Sprint", 8, Cu), S("polyline", { fill: "none", stroke: "#a0aec0", "stroke-width": "3", "stroke-dasharray": "6 3", points: c.value }, null, 8, Ou), S("polyline", { fill: "none", stroke: "#4299e1", "stroke-width": "4", points: h.value }, null, 8, Tu), (z(!0), Z(ce, null, ze(i.value, (m, _) => (z(), Z("g", { key: `actual-point-${_}`, class: "data-point" }, [S("circle", { cx: m.x, cy: m.y, r: "6", fill: "#4299e1", stroke: "#fff", "stroke-width": "3" }, null, 8, Iu), S("g", Nu, [S("rect", { class: "tooltip-bg", x: m.x - 45, y: m.y - 55, width: "90", height: "35", rx: "5" }, null, 8, Du), S("text", { class: "tooltip-text", x: m.x, y: m.y - 35, "text-anchor": "middle" }, " Dia " + q(_) + ": " + q(m.value), 9, Mu)])]))), 128))], 8, pu)), S("div", Bu, [(z(!0), Z(ce, null, ze(l.value, (m, _) => (z(), Z("button", { key: `a11y-point-${_}`, type: "button", class: "a11y-point", style: _n({ top: m.top + "%", left: m.left + "%" }) }, [S("span", $u, "Dia " + q(_) + ": " + q(m.value) + " tarefas restantes.", 1)], 4))), 128))])]), f[4] || (f[4] = zo(' <div class="chart-legend" data-v-df06843b><div class="legend-item" data-v-df06843b><span class="legend-swatch ideal" data-v-df06843b></span> Trabalho Ideal </div><div class="legend-item" data-v-df06843b><span class="legend-swatch actual" data-v-df06843b></span> Trabalho Real </div></div>', 2))]), S("div", Lu, [pe(p, { to: "/", class: "back-home-btn" }, { default: Yn(() => [...f[5] || (f[5] = [S("i", { class: "pi pi-home" }, null, -1), pn(" Voltar para Pgina Inicial ", -1)])]), _: 1 })])], 64) } } }, Vu = Zo(Fu, [["__scopeId", "data-v-df06843b"]]), Hu = { class: "sprint-health-container" }, ju = { class: "chart-wrapper" }, Uu = ["viewBox"], ku = { class: "grid-lines" }, Ku = ["y2"], Gu = ["y1", "x2", "y2"], Wu = ["y1", "x2", "y2"], qu = { class: "axis-labels y-axis" }, zu = ["x", "y"], Yu = ["x", "y"], Ju = { class: "axis-labels x-axis" }, Qu = ["x", "y"], Xu = ["transform"], Zu = ["x", "y"], ef = ["x", "y", "width", "height"], tf = ["x", "y"], nf = ["x", "y", "width", "height"], sf = ["x", "y"], rf = ["x", "y", "width", "height"], of = ["x", "y"], lf = ["x", "y", "width", "height"], cf = ["x", "y"], af = { class: "tooltip" }, uf = ["x", "y"], ff = ["x", "y"], df = ["x", "y"], hf = ["x", "y"], pf = ["x", "y"], gf = ["x", "y"], mf = { class: "a11y-layer" }, _f = { class: "sr-only" }, yf = { class: "navigation-footer" }, St = 1e3, dt = 500, nt = 80, Bt = 60, Sn = 40, vf = { __name: "VelocityView", setup(e) { const t = Ft([{ id: 1, name: "Sprint 1", todo: 0, progress: 0, testing: 0, done: 25 }, { id: 2, name: "Sprint 2", todo: 0, progress: 0, testing: 5, done: 30 }, { id: 3, name: "Sprint 3", todo: 10, progress: 5, testing: 5, done: 10 }]), n = dt - Bt, s = St - nt - Sn, r = ae(() => t.value.length), o = ae(() => { const f = Math.max(...t.value.map(p => Math.max(p.todo, p.progress, p.testing, p.done))); return Math.ceil(f * 1) }), i = ae(() => s / r.value), l = f => { const p = t.value.findIndex(m => m.id === f); return nt + p * i.value }, c = f => f <= 0 ? n : n - f / o.value * n, h = ae(() => { const _ = i.value * .9, T = _ / 4 * (1 - .05), H = _ / 4 * .05; return t.value.map(w => { const A = l(w.id), N = i.value * (.1 / 2), R = A + N, V = R + T + H, B = V + T + H, K = B + T + H, ee = c(w.todo), Te = c(w.progress), Ee = c(w.testing), Ie = c(w.done), Qe = n - ee, Ne = n - Te, Et = n - Ee, at = n - Ie; return { id: w.id, name: w.name, ...w, todoBar: { x: R, y: ee, width: T, height: Qe }, progressBar: { x: V, y: Te, width: T, height: Ne }, testingBar: { x: B, y: Ee, width: T, height: Et }, doneBar: { x: K, y: Ie, width: T, height: at }, tooltipPos: { x: A + i.value / 2 - 75, y: Math.min(ee, Te, Ee, Ie) } } }) }), a = ae(() => t.value.map(f => { const p = l(f.id) + i.value / 2; return { id: f.id, name: f.name, ...f, left: p / St * 100, top: 0, width: i.value / St * 100 } })); return (f, p) => { const m = Qn("router-link"); return z(), Z(ce, null, [S("div", Hu, [p[2] || (p[2] = S("h3", { id: "sprint-health-title", class: "chart-title" }, "Velocity", -1)), p[3] || (p[3] = S("div", { id: "sprint-health-description", class: "sr-only" }, [S("p", null, " Grfico de Velocidade da Sprint interativo. Mostra a distribuio de story points por status (A Fazer, Em Progresso, Em Teste, Concludo) para cada Sprint. Use a tecla Tab para navegar pelas Sprints. ")], -1)), S("div", ju, [(z(), Z("svg", { "aria-hidden": "true", viewBox: `0 0 ${St} ${dt}`, xmlns: "http://www.w3.org/2000/svg", class: "sprint-health-svg" }, [p[0] || (p[0] = S("title", null, "Velocity", -1)), p[1] || (p[1] = S("desc", null, "Grfico Velocity mostrando o status dos story points por sprint.", -1)), S("g", ku, [S("line", { x1: nt, y1: "0", x2: nt, y2: dt - Bt }, null, 8, Ku), S("line", { x1: nt, y1: dt - Bt, x2: St - Sn, y2: dt - Bt }, null, 8, Gu), (z(), Z(ce, null, ze(4, _ => S("line", { key: `grid-y-${_}`, x1: nt, y1: c(o.value * _ / 4), x2: St - Sn, y2: c(o.value * _ / 4) }, null, 8, Wu)), 64))]), S("g", qu, [S("text", { x: nt - 15, y: c(o.value), "text-anchor": "end", "alignment-baseline": "middle" }, q(o.value), 9, zu), S("text", { x: nt - 15, y: c(0), "text-anchor": "end", "alignment-baseline": "middle" }, "0", 8, Yu)]), S("g", Ju, [(z(!0), Z(ce, null, ze(t.value, _ => (z(), Z("text", { key: `label-x-${_.id}`, x: l(_.id) + i.value / 2, y: dt - Bt + 25, "text-anchor": "middle" }, q(_.name), 9, Qu))), 128))]), S("text", { class: "axis-title", "text-anchor": "middle", transform: `translate(30, ${(dt - Bt) / 2}) rotate(-90)` }, " STORY POINTS ", 8, Xu), S("text", { class: "axis-title", x: (St + nt - Sn) / 2, y: dt - 10, "text-anchor": "middle" }, "SPRINTS", 8, Zu), (z(!0), Z(ce, null, ze(h.value, _ => (z(), Z("g", { key: `bar-group-${_.id}`, class: "data-point" }, [S("rect", { x: _.todoBar.x, y: _.todoBar.y, width: _.todoBar.width, height: _.todoBar.height, class: "bar bar-todo" }, null, 8, ef), _.todo > 0 ? (z(), Z("text", { key: 0, class: "bar-label", x: _.todoBar.x + _.todoBar.width / 2, y: _.todoBar.y - 6, "text-anchor": "middle" }, q(_.todo), 9, tf)) : An("", !0), S("rect", { x: _.progressBar.x, y: _.progressBar.y, width: _.progressBar.width, height: _.progressBar.height, class: "bar bar-progress" }, null, 8, nf), _.progress > 0 ? (z(), Z("text", { key: 1, class: "bar-label", x: _.progressBar.x + _.progressBar.width / 2, y: _.progressBar.y - 6, "text-anchor": "middle" }, q(_.progress), 9, sf)) : An("", !0), S("rect", { x: _.testingBar.x, y: _.testingBar.y, width: _.testingBar.width, height: _.testingBar.height, class: "bar bar-testing" }, null, 8, rf), _.testing > 0 ? (z(), Z("text", { key: 2, class: "bar-label", x: _.testingBar.x + _.testingBar.width / 2, y: _.testingBar.y - 6, "text-anchor": "middle" }, q(_.testing), 9, of)) : An("", !0), S("rect", { x: _.doneBar.x, y: _.doneBar.y, width: _.doneBar.width, height: _.doneBar.height, class: "bar bar-done" }, null, 8, lf), _.done > 0 ? (z(), Z("text", { key: 3, class: "bar-label", x: _.doneBar.x + _.doneBar.width / 2, y: _.doneBar.y - 6, "text-anchor": "middle" }, q(_.done), 9, cf)) : An("", !0), S("g", af, [S("rect", { class: "tooltip-bg", x: _.tooltipPos.x, y: _.tooltipPos.y - 105, width: "150", height: "95", rx: "5" }, null, 8, uf), S("text", { class: "tooltip-text", x: _.tooltipPos.x + 75, y: _.tooltipPos.y - 85, "text-anchor": "middle" }, q(_.name), 9, ff), S("text", { class: "tooltip-text-small", x: _.tooltipPos.x + 15, y: _.tooltipPos.y - 60, "text-anchor": "start" }, "A Fazer: " + q(_.todo), 9, df), S("text", { class: "tooltip-text-small", x: _.tooltipPos.x + 15, y: _.tooltipPos.y - 45, "text-anchor": "start" }, "Progresso: " + q(_.progress), 9, hf), S("text", { class: "tooltip-text-small", x: _.tooltipPos.x + 15, y: _.tooltipPos.y - 30, "text-anchor": "start" }, "Teste: " + q(_.testing), 9, pf), S("text", { class: "tooltip-text-small", x: _.tooltipPos.x + 15, y: _.tooltipPos.y - 15, "text-anchor": "start" }, "Concludo: " + q(_.done), 9, gf)])]))), 128))], 8, Uu)), S("div", mf, [(z(!0), Z(ce, null, ze(a.value, _ => (z(), Z("button", { key: `a11y-point-${_.id}`, type: "button", class: "a11y-point", style: _n({ top: _.top + "%", left: _.left + "%", width: _.width + "%", height: "100%" }) }, [S("span", _f, q(_.name) + ". " + q(_.todo) + " A Fazer. " + q(_.progress) + " Em Progresso. " + q(_.testing) + " Em Teste. " + q(_.done) + " Concludo. ", 1)], 4))), 128))])]), p[4] || (p[4] = zo(' <div class="chart-legend" data-v-1bc3bf11><div class="legend-item" data-v-1bc3bf11><span class="legend-swatch bar-todo" data-v-1bc3bf11></span> A Fazer </div><div class="legend-item" data-v-1bc3bf11><span class="legend-swatch bar-progress" data-v-1bc3bf11></span> Em Progresso </div><div class="legend-item" data-v-1bc3bf11><span class="legend-swatch bar-testing" data-v-1bc3bf11></span> Em Teste </div><div class="legend-item" data-v-1bc3bf11><span class="legend-swatch bar-done" data-v-1bc3bf11></span> Concludo </div></div>', 2))]), S("div", yf, [pe(m, { to: "/", class: "back-home-btn" }, { default: Yn(() => [...p[5] || (p[5] = [S("i", { class: "pi pi-home" }, null, -1), pn(" Voltar para Pgina Inicial ", -1)])]), _: 1 })])], 64) } } }, bf = Zo(vf, [["__scopeId", "data-v-1bc3bf11"]]), hi = za({ history: Sa("/poc/"), routes: [{ path: "/", name: "home", component: () => Uc(() => import("./HomeView-DWbD5oR0.js"), __vite__mapDeps([0, 1])), meta: { title: "Home" } }, { path: "/kanban", name: "kanban", component: fu, meta: { title: "Kanban" } }, { path: "/burndown", name: "burndown", component: Vu, meta: { title: "Grfico de Burndown" } }, { path: "/velocity", name: "velocity", component: bf, meta: { title: "Grfico de Velocidade da Sprint" } }] }), pi = $c(Vc); hi.beforeEach((e, t, n) => { e.meta && e.meta.title && (document.title = e.meta.title), n() }); pi.use(hi); pi.mount("#app"); export { Zo as _, S as a, pe as b, Z as c, pn as d, z as o, Qn as r, Yn as w };
